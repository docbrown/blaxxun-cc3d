<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>GMesh Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:45:51 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>gshell.h</h1>This is the verbatim text of the gshell.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/
#ifndef _GSHELL_H
#define _GSHELL_H
/******************************************************************************
@doc

@module GShell.h - GLView graphical objects     |

GShell.h
Copyright (c) 1993 - 1999 by Holger Grahn
All rights reserved

Purpose:

Classes:

GFaceList               IntArray for storing face information

GEdgeList               IntArray for storing edge
                                                                           
GVertex                 structure storing complete vertex information
GVertexI                like GVertex, but information stored by index (ref. to table)

GObject                 root for Graphical objects
        GShell          polyhedral object
                GMesh   regular quad mesh
                GPolyggon       

Notes:

Changes:

$Revision: 1.19 $
$Log: gshell.h,v $
Revision 1.19  1999/07/06 16:54:53  tom
*** empty log message ***



Todo :

******************************************************************************/
#ifdef _GV

#include &lt;gvsubnode.h&gt;

#endif

#include "grender.h"


// Forward
class <a class="code" href="class_pointarray.html">PointArray</a>;

class <a class="code" href="class_renderstate.html">RenderState</a>;

class <a class="code" href="class_gshell.html">GShell</a>;

class <a class="code" href="class_gsubmesh.html">GSubMesh</a>;

class <a class="code" href="class_ghitinfo.html">GHitInfo</a>;

class <a class="code" href="class_rapid_model.html">RAPID_model</a>;
class <a class="code" href="class_gconvexvolume.html">GConvexVolume</a>;
class <a class="code" href="class_gcollisionresponse.html">GCollisionResponse</a>;




//@class FaceList array storing a set of faces by vertex index
class <a class="code" href="class_gfacelist.html">GFaceList</a> : public <a class="code" href="class_intarray.html">IntArray</a> {
public:
                <a class="code" href="class_gfacelist.html#a0">GFaceList</a>() : <a class="code" href="class_intarray.html">IntArray</a>()                {};
                <a class="code" href="class_gfacelist.html#a0">GFaceList</a>(int n) : <a class="code" href="class_intarray.html">IntArray</a>(n) {};
                <a class="code" href="class_gfacelist.html#a0">GFaceList</a>(int n, const int *iT): <a class="code" href="class_intarray.html">IntArray</a>(n,iT) {};
                <a class="code" href="class_gfacelist.html#a0">GFaceList</a>(const <a class="code" href="class_intarray.html">IntArray</a> &amp; arg): <a class="code" href="class_intarray.html">IntArray</a>(arg) {};

                void <a class="code" href="class_gfacelist.html#a4">SetPolygon</a>(int n);
                
                int <a class="code" href="class_gfacelist.html#a5">SetGrid</a>(int rows,int cols,gbool quads=gtrue,gbool closeCols=gfalse,gbool closeRows=gfalse);

                int <a class="code" href="class_gfacelist.html#a6">SetPoints</a>(int nPoints,int start=0);

                int <a class="code" href="class_gfacelist.html#a7">SetPolyline</a>(<a class="code" href="class_gfacelist.html">GFaceList</a> &amp;f,int start=0);


                int <a class="code" href="class_gfacelist.html#a8">SetFaceListInventor</a>(int nf,const int *fp);

                void <a class="code" href="class_gfacelist.html#a9">AppendPoint</a>(int i) { int e = <a class="code" href="class_array.html#a21">Length</a>();
                                                                                                <a class="code" href="class_array.html#a32">Resize</a>(e+2);
                                                                                                int *fp = <a class="code" href="class_array.html#a20">DataRW</a>() + e;
                                                                                                *fp++=1; *fp++=i;
                                                                                                };


                void <a class="code" href="class_gfacelist.html#a10">AppendEdge</a>(int i1, int i2) { int e = <a class="code" href="class_array.html#a21">Length</a>();
                                                                                                <a class="code" href="class_array.html#a32">Resize</a>(e+3);
                                                                                                int *fp = <a class="code" href="class_array.html#a20">DataRW</a>() + e;
                                                                                                *fp++=2; *fp++=i1;*fp++ = i2;
                                                                                                };

                void <a class="code" href="class_gfacelist.html#a11">AppendTri</a>(int i1, int i2,int i3) { int e = <a class="code" href="class_array.html#a21">Length</a>();
                                                                                                <a class="code" href="class_array.html#a32">Resize</a>(e+4);
                                                                                                int *fp = <a class="code" href="class_array.html#a20">DataRW</a>() + e;
                                                                                                *fp++=3; *fp++=i1;*fp++ = i2; *fp++=i3;
                                                                                                };

                void <a class="code" href="class_gfacelist.html#a12">AppendQuad</a>(int i1, int i2,int i3,int i4) { int e = <a class="code" href="class_array.html#a21">Length</a>();
                                                                                                <a class="code" href="class_array.html#a32">Resize</a>(e+5);
                                                                                                int *fp = <a class="code" href="class_array.html#a20">DataRW</a>() + e;
                                                                                                *fp++=4; *fp++=i1;*fp++ = i2; *fp++=i3; *fp++=i4;
                                                                                                };
                int <a class="code" href="class_gfacelist.html#a13">GetFaceOffset</a>(int nth);

                int <a class="code" href="class_gfacelist.html#a14">GetFaceCount</a>(int offset=0);

                int <a class="code" href="class_gfacelist.html#a14">GetFaceCount</a>(int offset,int *holecnt,int *tricnt);


                int <a class="code" href="class_gfacelist.html#a16">GetFaceSize</a>(int offset=0,int cnt=1);
                

                int <a class="code" href="class_gfacelist.html#a17">GetTriangleCount</a>(int offset=0);


                int <a class="code" href="class_gfacelist.html#a18">GetTriangleCountReal</a>(int offset=0);

                int <a class="code" href="class_gfacelist.html#a19">GetLineCountReal</a>(int offset=0);

                // Compute # lines for facelist, starting with an optional offset 
                // closed = 1, assume extra closing edge 
                int <a class="code" href="class_gfacelist.html#a20">GetLineCount</a>(int offset=0,gbool closed=gfalse);


                int <a class="code" href="class_gfacelist.html#a21">ReverseFaces</a>(int offset=0);


                int <a class="code" href="class_gfacelist.html#a22">DeleteNth</a>(int nth=0,int cnt=1);

                // optimize face list (for triangles, and strip building)
                // remove degenerated triangles
                // resulting face might be shorter
                int <a class="code" href="class_gfacelist.html#a23">Optimize</a>(gbool flip=gfalse);



};


#ifdef _OGL
//\@func triangulate a facelist into triangles using the GLU triangulator
int <a class="code" href="gshelltriang.h.html#a0">tesselateFaceList</a> ( <a class="code" href="class_gfacelist.html">GFaceList</a> &amp;f, //@parm input facelist
                                                <a class="code" href="class_pointarray.html">PointArray</a> &amp;v, //@parm corresponding vertices for indices in f
                                                <a class="code" href="class_intarray.html">IntArray</a> *vmap, // @parm optional vertex map table
                                                <a class="code" href="class_gfacelist.html">GFaceList</a> &amp;newf, //@parm output: triangulated facelist
                                                <a class="code" href="class_intarray.html">IntArray</a> *new2old,      //@parm output : optional mapping from new triangles to old face indices
                        <a class="code" href="class_gshell.html">GShell</a> * theShell);  //@parm optional shell to append vertices too
#endif



//@class EdgeList array, storing a list of edges by 2 vertex indices
class <a class="code" href="class_gedgelist.html">GEdgeList</a> : public <a class="code" href="class_intarray.html">IntArray</a> {
public:
                <a class="code" href="class_gedgelist.html#a0">GEdgeList</a>() : <a class="code" href="class_intarray.html">IntArray</a>()                {};
                <a class="code" href="class_gedgelist.html#a0">GEdgeList</a>(int n) : <a class="code" href="class_intarray.html">IntArray</a>(n) {};
                <a class="code" href="class_gedgelist.html#a0">GEdgeList</a>(int n, const int *iT): <a class="code" href="class_intarray.html">IntArray</a>(n,iT) {};
                <a class="code" href="class_gedgelist.html#a0">GEdgeList</a>(const <a class="code" href="class_intarray.html">IntArray</a> &amp; arg): <a class="code" href="class_intarray.html">IntArray</a>(arg) {};

};

//@class root object of graphical output objects
class <a class="code" href="class_gobject.html">GObject</a> : 

#ifdef _GV

        public <a class="code" href="class_gvnode.html">GvNode</a>
{
      GV_NODE_HEADER(<a class="code" href="class_gobject.html">GObject</a>);
#else   // not GV

        public <a class="code" href="class_ggeometry.html">GGeometry</a> 
{
                <a class="code" href="class_gvnode.html#a0">RT</a>(<a class="code" href="class_ggeometry.html">GGeometry</a>);
                <a class="code" href="class_gobject.html#c1">GObject</a>();
                <a class="code" href="class_gobject.html#c2">~GObject</a>();
#endif      

public:
                <a class="code" href="class_bbox.html">BBox</a> bbox;      // bounding box for object 

                // virtual GObject* Eval() { return(this); }

                virtual void <a class="code" href="class_gobject.html#a0">SetChanged</a>() { };
                
                virtual void <a class="code" href="class_gobject.html#a1">UnSetChanged</a>() { };
                
                virtual int <a class="code" href="class_gobject.html#a2">Changed</a>() { return(0); }

                virtual <a class="code" href="class_bbox.html">BBox</a> &amp; <a class="code" href="class_gobject.html#a3">GetBBox</a>()  { return bbox; }
};

/*
        Bitmask describing state information about shell object
*/

enum
                shell_flags {
                SHELL_CONVEX=1,                                 // convex polyhedron
                SHELL_CLOSED=2,                                 // closed polyhedron
                SHELL_SHADE_FLAT=4,
                SHELL_BOUNDS_OK=8,
                SHELL_VNORMALS_COMPUTED=16,     // Vertex Normals set via ComputeVertexNormals
                SHELL_FNORMALS_COMPUTED=32,     // Face Normals set via ComputeFaceNormals
                SHELL_FINFO_OK=64,
                SHELL_TRIANGULATED=128,                 // face list only contains triangles
                SHELL_EDGES_OK=256,                     // edge list has been constructed
                SHELL_COMPUTE_PRIMLIST=512,     // Build primitive list (tristrips)
                SHELL_FLIP_NORMALS=1024,                // Flip Normals during computation (face normals)
                SHELL_FCOLORS_COMPUTED=2048,    // Face Colors are computed from Group information
                SHELL_PRIMLIST_COMPUTED=4096,   // Primitivlist is computed
                SHELL_HAS_HOLE_FACES=8192,              // face list contains hole faces nr ok ?
                SHELL_HAS_CONVEX_FACES=16384,   // face list contains convex faces
                SHELL_PLANAR=16384*2,                   // this is a planar object, all face are in the same plane 
                };
/*
        Bitmask describing actions to be done on shell object
*/

enum shell_actions {
                SHELL_COMPUTE_MAXI=1,                           // recompute max indices
                SHELL_COMPUTE_FNORMALS=2,                       // recompute face normals
                SHELL_COMPUTE_VNORMALS=4,                       // recompute vertex normals
                SHELL_COMPUTE_BBOX=8,                           // recompute bounding box
                SHELL_COMPUTE_TRIANGULATION=16,         // triangulate shell
                SHELL_COMPUTE_PRIMITIVELIST=32,         // recompute primitve list 
                SHELL_COMPUTE_EDGELIST=64,                      // recompute face colors from group
                SHELL_COMPUTE_FCOLORS_FROM_GROUP=128,   // recompute face colors from group
                SHELL_REDRAW=256,                               // recompute face colors from group
        SHELL_COMPUTE_EXBUF=512,          // create D3D EXECUTE Buffer
        SHELL_UPDATE_EXBUF_VERT=1024,    // update vertices in D3D EXECUTE Buffer
        SHELL_UPDATE_SUBMESH_VERT=1024*2,  // update vertices in D3D EXECUTE Buffer
        SHELL_UPDATE_RAPID_MODEL=1024*2*2  // update the RAPID model data structure
                };

enum shell_changed_flags {
                SHELL_VERTICES_CHANGED=1,       // vertex positions changes
                SHELL_FACELIST_CHANGED=2,       // face information changed
                SHELL_PRIMLIST_CHANGED=4,       
                SHELL_ATTRIBUTES_CHANGED=8,
                SHELL_VERTEX_ATTRIBUTES_CHANGED=16, // any vertex attribute changed
                SHELL_FACE_ATTRIBUTES_CHANGED=32,   // any face attribute changed
                SHELL_CHANGED=64,
                SHELL_CREATED=128,
                SHELL_FACE_GROUP_CHANGED=256,
                SHELL_VERTS_CHANGED=512,            // the verts array changed
                SHELL_VERTS_LENGTH_CHANGED=1024,    // GetVertexCount changed 

                };

//xxxx//@typee shell_primitive_op | Op codes for precompiled gl low level primitive list
enum shell_primitive_op {
                                SHELL_END=1,                    // END OF primitive
                                SHELL_POINTS,                   // equivalent glBegin(MODE) values
                                SHELL_LINES,
                                SHELL_LINE_LOOP,
                                SHELL_LINE_STRIP,
                                SHELL_TRIANGLES,
                                SHELL_TRIANGLE_STRIP,
                                SHELL_TRIANGLE_FAN,
                                SHELL_QUADS,
                                SHELL_QUAD_STRIP,
                                SHELL_POLYGON,
                                SHELL_TRISTRIP_FACEINDEX,               // v1 v2 fi v3 fi v4
                                SHELL_SET_MATERIAL,             // index        set material by index
                                SHELL_SET_COLOR,                // index        set color by index
                                };


typedef struct {
                float plane_d;                  // Plane distance, together with face normals forms Plane EQ
                int poly_u:2;                   // major axis 1
                int poly_v:2;                   // major axis 2
                } <a class="code" href="class_shell_face_info.html">shell_face_info</a>;


enum shell_data {
                SHELL_VERTEX=1,
                SHELL_VERTEX_NORMAL=2,
                SHELL_VERTEX_COLOR=4,
                SHELL_VERTEX_PARAMETER=8,

                SHELL_FACE_NORMAL=512,
                SHELL_FACE_COLOR=1024,

                SHELL_FACE_GROUP=2048,

};

//@class GVertex, all vertex data in one structure,
class <a class="code" href="class_gvertex.html">GVertex</a> {
public :
                <a class="code" href="class_point.html">Point</a> v;                
                <a class="code" href="class_point.html">Point</a> n;                
                <a class="code" href="class_point.html">Point</a> c;                
                <a class="code" href="class_point.html">Point</a> p;                

                void <a class="code" href="class_gvertex.html#a0">Zero</a>() { v.<a class="code" href="class_point.html#a6">Set</a>(0.0,0.0,0.0); n=c=p=v; }

                friend <a class="code" href="class_gvertex.html">GVertex</a>&amp; <a class="code" href="class_gvertex.html#l0">Interpolate</a> (const <a class="code" href="class_gvertex.html">GVertex</a>&amp; A,float ta, const <a class="code" href="class_gvertex.html">GVertex</a>&amp; B,float tb, <a class="code" href="class_gvertex.html">GVertex</a> &amp;Result);

#ifdef _3DV
                int io(AStream &amp;a);
#endif _3DV

};

//@class GVertexI, all vertex data in one structure, but by index array reference
class <a class="code" href="class_gvertexi.html">GVertexI</a> {
public :
                int v;  
                int n;  
                int c;  
                int p;  

                void <a class="code" href="class_gvertexi.html#a0">Zero</a>() { v=n=c=p=-1; }

                int operator== ( const <a class="code" href="class_gvertexi.html">GVertexI</a> &amp;b) 
                        {
                                return(v == b.v &amp;&amp; n == b.n &amp;&amp; c == b.c &amp;&amp; p == b.p); 
                        }
#ifdef _3DV
                int io(AStream &amp;a);
#endif _3DV

};

//
// GSubMesh - store a subset of shell faces &amp; references vertices 
//

class <a class="code" href="class_gsubmesh.html">GSubMesh</a> {
public :

        <a class="code" href="class_gshell.html">GShell</a> *s;              // shell for submesh
        <a class="code" href="class_intarray.html">IntArray</a> vmap;  // mapping s-&gt;v[i] = this-&gt;vmap[i], for updating vertex coordinates

        
        <a class="code" href="class_rgbacolor.html">RGBAColor</a> diffuseColor; // optional faceColor 
        int faceStart;                  // offset of facelist in parent shell
        int faceEnd;                    // offset of facelist in parent shell

        <a class="code" href="class_gsubmesh.html">GSubMesh</a> *next;

        <a class="code" href="class_gsubmesh.html#a0">GSubMesh</a>() : s(NULL),next(NULL),faceStart(-1),faceEnd(-1) { }

        <a class="code" href="class_gsubmesh.html#a1">~GSubMesh</a>(); // destruct shell and next 

};


//
// GShell - store vertex list with optional attributes and face information
//

//@class a set of vertices + faces
class <a class="code" href="class_gshell.html">GShell</a> : public <a class="code" href="class_gobject.html">GObject</a>  
{

public:

#ifdef _GV
      GV_NODE_HEADER(<a class="code" href="class_gshell.html">GShell</a>);

#define GEvalAs_TYPE GvNode

#else
      <a class="code" href="class_gobject.html#c0">RT</a>(<a class="code" href="class_gshell.html">GShell</a>);
      <a class="code" href="class_gshell.html#a1">GShell</a>();
          <a class="code" href="class_gshell.html#a2">~GShell</a>();

#define GEvalAs_TYPE GGeometry

#endif



public:

                <a class="code" href="class_pointarray.html">PointArray</a> v;   // vertex coordinates
                <a class="code" href="class_pointarray.html">PointArray</a> vn;  // vertex normals
                <a class="code" href="class_pointarray.html">PointArray</a> vc;  // vertex colors
                <a class="code" href="class_pointarray.html">PointArray</a> vp;  // vertex parameters

                // Katmai datastructures 

                <a class="code" href="class_pointarray4.html">PointArray4</a> kv;         // vertex coordinates
                <a class="code" href="class_pointarray4.html">PointArray4</a> kvn;        // vertex normals
                <a class="code" href="class_pointarray4.html">PointArray4</a> kvc;        // vertex colors
                <a class="code" href="class_pointarray4.html">PointArray4</a> kvp;        // vertex parameters

                <a class="code" href="class_pointarray4.html">PointArray4</a>  kfn;       // face normals
                <a class="code" href="class_pointarray4.html">PointArray4</a>  kfv;       // representative face vertex 


                <a class="code" href="class_gvertexi.html">GVertexI</a> maxI;  // maximum indices for current lists

                <a class="code" href="class_gfacelist.html">GFaceList</a> f;    // facelist
                                                // structure :
                                                // #verts of face
                                                // #verts vert indices
                                                // optional nverts &lt;0 hole for preceding face

                int nfaces;     // number of faces

                <a class="code" href="class_intarray.html">IntArray</a> prims; // primitive list with gl Opcodes + primitives (triangle strips)
                                                // optionally computed from facelist f

                <a class="code" href="class_pointarray.html">PointArray</a> fn;  // face normals
                <a class="code" href="class_pointarray.html">PointArray</a> fc;  // face colors
                <a class="code" href="class_intarray.html">IntArray</a>   fcI; // index from face number into fc table if present 

                // int *fgroup; [nfaces]
                // int ngroups;
                // FGroup * groups;                                     // ShadeFlat, Color ???

                <a class="code" href="class_shell_face_info.html">shell_face_info</a> *finfo; // info per plane for speed of ray-intersect operation

                int *e;                 // edge list (computed from facelist)
                int ne;                 // length of edgelist = number of edges
                // to think about: optional explicit edge table, or table with invisible edges ?


                static int initial_flags;
                static int initial_edit_flags;

                int flags;              // different flags
                int edit_flags; // what has been changed
                int actions;    // type of action to be computed on shell 
                int has;                // type of data present ( computed from update)

public:
          // constructor
          // GV_NODE_HEADER GShell();
          <a class="code" href="class_gshell.html#a1">GShell</a>(       int new_nv,const <a class="code" href="class_point.html">Point</a> *new_v,
                                int new_nf=0,const int *new_f=NULL);

         
          // construct by mesh 
          <a class="code" href="class_gshell.html#a1">GShell</a>(int cols,int rows,const <a class="code" href="class_point.html">Point</a> *new_v);


     // destructor
         //GV_NODE_HEADER ~GShell();
     //GV_NODE_HEADER virtual GvFieldData *getFieldData();


protected :
          virtual void <a class="code" href="class_gshell.html#b0">Zero</a>();                  // Null out all members (internal)

public: 
        virtual int <a class="code" href="class_gshell.html#a5">Update</a>(); 

        virtual int <a class="code" href="class_gshell.html#a6">UpdateActions</a>(); 
        
        virtual <a class="code" href="class_gshell.html">GShell</a>* <a class="code" href="class_gshell.html#a7">CopyGeometry</a>(<a class="code" href="class_gshell.html">GShell</a> *dest=0) const;
        
        virtual <a class="code" href="class_gshell.html">GShell</a>*  <a class="code" href="class_gshell.html#a8">Copy</a>(<a class="code" href="class_gshell.html">GShell</a> *dest=0) const;

        virtual void <a class="code" href="class_gshell.html#a9">SetV</a>(int new_nv,const <a class="code" href="class_point.html">Point</a> *new_v);
        virtual void <a class="code" href="class_gshell.html#a10">SetVByRef</a>(int new_nv,const <a class="code" href="class_point.html">Point</a> *new_v);
        void <a class="code" href="class_gshell.html#a9">SetV</a>(const <a class="code" href="class_pointarray.html">PointArray</a> &amp;new_v);
        
        virtual void <a class="code" href="class_gshell.html#a12">SetVN</a>(int n_vn,const <a class="code" href="class_point.html">Point</a> *new_vn,int normalize=0);
        virtual void <a class="code" href="class_gshell.html#a13">SetVNByRef</a>(int n_vn,const <a class="code" href="class_point.html">Point</a> *new_vn,int normalize=0);
        void <a class="code" href="class_gshell.html#a12">SetVN</a>(const <a class="code" href="class_pointarray.html">PointArray</a> &amp;new_vn,int normalize=0);
        //void SetVNByRef(Point *new_vn);
        
        virtual void <a class="code" href="class_gshell.html#a15">SetVC</a>(int n_vn,const <a class="code" href="class_point.html">Point</a> *new_vc);
        void <a class="code" href="class_gshell.html#a16">SetVCByRef</a>(int n_vc,const <a class="code" href="class_point.html">Point</a> *new_vc);
        void <a class="code" href="class_gshell.html#a15">SetVC</a>(const <a class="code" href="class_pointarray.html">PointArray</a> &amp;new_vc);
        //void SetVCByRef(Point *new_vc);

        virtual  void <a class="code" href="class_gshell.html#a18">SetVP</a>(int n_vp,const <a class="code" href="class_point.html">Point</a> *new_vp);
        void <a class="code" href="class_gshell.html#a19">SetVPByRef</a>(int n_vp,const <a class="code" href="class_point.html">Point</a> *new_vp);
        void <a class="code" href="class_gshell.html#a18">SetVP</a>(const <a class="code" href="class_pointarray.html">PointArray</a> &amp;new_vp);
        //void SetVPByRef(Point *new_vp);

        virtual void <a class="code" href="class_gshell.html#a21">SetFN</a>(int n_fn,const <a class="code" href="class_point.html">Point</a> *new_fn,int normalize=0);
        void <a class="code" href="class_gshell.html#a22">SetFNByRef</a>(int n_fn,const <a class="code" href="class_point.html">Point</a> *new_fn);
        void <a class="code" href="class_gshell.html#a21">SetFN</a>(const <a class="code" href="class_pointarray.html">PointArray</a> &amp;new_fn,int normalize=0);
        //void SetFNByRef(int n_f,Point *new_vn);

        virtual void <a class="code" href="class_gshell.html#a24">SetFC</a>(int n_fc,const <a class="code" href="class_point.html">Point</a> *new_fc);
        void <a class="code" href="class_gshell.html#a25">SetFCByRef</a>(int n_fc,const <a class="code" href="class_point.html">Point</a> *new_fc);
        void <a class="code" href="class_gshell.html#a24">SetFC</a>(const <a class="code" href="class_pointarray.html">PointArray</a> &amp;new_fc);

        virtual void <a class="code" href="class_gshell.html#a27">SetFCByIndex</a>(int n_fci,const int *new_fci,int n_fc,const <a class="code" href="class_point.html">Point</a> *new_fc);

        void <a class="code" href="class_gshell.html#a28">SetFCIndex</a>(int n_fci,const int *new_fci);
        void <a class="code" href="class_gshell.html#a29">SetFCIndexByRef</a>(int n_fci,const int *new_fci);
        void <a class="code" href="class_gshell.html#a28">SetFCIndex</a>(const <a class="code" href="class_intarray.html">IntArray</a> &amp;new_fci);

        void <a class="code" href="class_gshell.html#a31">SetFaceList</a>(int new_nf,const int *new_f);
        void <a class="code" href="class_gshell.html#a32">SetFaceListByRef</a>(int new_nf,const int *new_f);
        void <a class="code" href="class_gshell.html#a31">SetFaceList</a>(const <a class="code" href="class_gfacelist.html">GFaceList</a> &amp;new_f);

        void <a class="code" href="class_gshell.html#a34">SetPrimitiveList</a>(int new_np,const int *new_prims);
        void <a class="code" href="class_gshell.html#a34">SetPrimitiveList</a>(const <a class="code" href="class_intarray.html">IntArray</a> &amp;new_p);

        void <a class="code" href="class_gshell.html#a36">SetEdgeList</a>(int new_ne,const int *new_e);
        void <a class="code" href="class_gshell.html#a37">SetEdgeListByRef</a>(int new_ne,int *new_e);

        // get functions, recompute values if necessary
        virtual const <a class="code" href="class_pointarray.html">PointArray</a>&amp; <a class="code" href="class_gshell.html#a38">GetV</a>();
        virtual const <a class="code" href="class_pointarray.html">PointArray</a>&amp; <a class="code" href="class_gshell.html#a39">GetVN</a>();
        virtual const <a class="code" href="class_pointarray.html">PointArray</a>&amp; <a class="code" href="class_gshell.html#a40">GetVP</a>();
        virtual const <a class="code" href="class_pointarray.html">PointArray</a>&amp; <a class="code" href="class_gshell.html#a41">GetVC</a>();

        virtual const <a class="code" href="class_pointarray.html">PointArray</a>&amp; <a class="code" href="class_gshell.html#a42">GetFN</a>();
        virtual const <a class="code" href="class_pointarray.html">PointArray</a>&amp; <a class="code" href="class_gshell.html#a43">GetFC</a>();

        // Editing functions

        // vertex append / lookup functions

        
        virtual int <a class="code" href="class_gshell.html#a44">FindNearestV</a>(const <a class="code" href="class_point.html">Point</a> &amp;p,float &amp;distance2);

        static float maxLookupDistance2;
        
        void <a class="code" href="class_gshell.html#a45">SetMaxLookupDistance</a>(float r) { maxLookupDistance2 = r*r; }

        int <a class="code" href="class_gshell.html#a46">AppendV</a>(const <a class="code" href="class_point.html">Point</a> &amp;p,int doLookup=1);
        
        // transform points, if optional attribute m is present
        int <a class="code" href="class_gshell.html#a46">AppendV</a>(const <a class="code" href="class_pointarray.html">PointArray</a> &amp;p,int doLookup=1,<a class="code" href="class_intarray.html">IntArray</a> *old2new=0, const <a class="code" href="class_matrix.html">Matrix</a> *m=NULL);

        virtual int <a class="code" href="class_gshell.html#a48">GetVertexCnt</a>() { return (v.<a class="code" href="class_array.html#a21">Length</a>()); }

        // facelist append functions
        
        virtual int <a class="code" href="class_gshell.html#a49">AppendVertex</a>(const <a class="code" href="class_point.html">Point</a> &amp;p,int doLookup);

        virtual int <a class="code" href="class_gshell.html#a49">AppendVertex</a>(const <a class="code" href="class_gvertex.html">GVertex</a> &amp;vert);

        
        virtual int <a class="code" href="class_gshell.html#a49">AppendVertex</a>(const <a class="code" href="class_pointarray.html">PointArray</a> &amp;p,int doLookup,<a class="code" href="class_intarray.html">IntArray</a> *old2new);


        int <a class="code" href="class_gshell.html#a52">AppendFacelist</a>(<a class="code" href="class_intarray.html">IntArray</a> &amp;p,int doLookup=1,<a class="code" href="class_intarray.html">IntArray</a> *old2new=0);

        int <a class="code" href="class_gshell.html#a53">AppendEdge</a>(<a class="code" href="class_point.html">Point</a> &amp;p1,<a class="code" href="class_point.html">Point</a> &amp;p2,int doLookup=1);

        int <a class="code" href="class_gshell.html#a54">AppendTriangle</a>(<a class="code" href="class_point.html">Point</a> &amp;p1,<a class="code" href="class_point.html">Point</a> &amp;p2, <a class="code" href="class_point.html">Point</a> &amp;p3,int doLookup=1);

        int <a class="code" href="class_gshell.html#a55">AppendPolygon</a>(const <a class="code" href="class_pointarray.html">PointArray</a> &amp;pts,int doLookup=1);

        virtual int <a class="code" href="class_array.html#a36">Append</a>(<a class="code" href="class_gshell.html">GShell</a> &amp;s,int doLookup=1, const <a class="code" href="class_matrix.html">Matrix</a> *m=NULL);

        int <a class="code" href="class_gshell.html#a57">DeleteFaces</a>(int nthOffset,int cnt=1);

        int <a class="code" href="class_gshell.html#a58">DeleteVerts</a>(int nthOffset,int cnt=1);

        virtual void <a class="code" href="class_gshell.html#a59">ComputeBBox</a>(<a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_box.html">box</a>);

        virtual <a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_gobject.html#a3">GetBBox</a>();


        void <a class="code" href="class_gshell.html#a61">ComputeBounds</a>();

        // !  Compute the center of all points by averaging 
        virtual void <a class="code" href="class_gshell.html#a62">ComputeCenter</a>(<a class="code" href="class_point.html">Point</a> &amp;center);

        // get bounding box of node // GvNode virtual function 
        virtual GvBool <a class="code" href="class_gvnode.html#a37">getBBox</a>(<a class="code" href="class_bbox.html">BBox</a> &amp;bbox);

        // result 0 not planar, 1: shell is planar, plane computed, 2: plane of first poly
        virtual int <a class="code" href="class_gshell.html#a64">isPlanar</a>(<a class="code" href="class_plane.html">Plane</a> &amp;plane);


        // is shell convex 
        virtual gbool <a class="code" href="class_gshell.html#a65">isConvex</a>();

        // is p outside the object
        // may fall back to very simply outside bbox computation
        // needed for Occlusion node 

        virtual gbool <a class="code" href="class_gshell.html#a66">isOutside</a>(const <a class="code" href="class_point.html">Point</a> &amp;p);

        
        // tri2face maps triangle # i to shells face number #fi
        // Return: number of triangles
        virtual int <a class="code" href="class_gshell.html#a67">ComputeTriangles</a>(<a class="code" href="class_gfacelist.html">GFaceList</a> &amp;<a class="code" href="class_tri.html">tri</a>,<a class="code" href="class_intarray.html">IntArray</a> &amp;tri2face,int useTriangulator=0);

        virtual int <a class="code" href="class_gshell.html#a68">Triangulate</a>();


        virtual void <a class="code" href="class_gshell.html#a69">GetVertexParametersNative</a>(int n,<a class="code" href="class_point.html">Point</a> *vp);

        // ! get all vertex data for vertex i,
        // if values are not present they will not be stored
        virtual int <a class="code" href="class_gshell.html#a70">GetVertex</a>(int i, <a class="code" href="class_gvertex.html">GVertex</a> &amp;vert)
        {
                        if (i &lt; v.<a class="code" href="class_array.html#a21">Length</a>())  vert.v = v[i];                     // the vertex coordinates
                        if (i &lt; vn.<a class="code" href="class_array.html#a21">Length</a>()) vert.n = vn[i];    // the vertex normal
                        if (i &lt; vc.<a class="code" href="class_array.html#a21">Length</a>()) vert.c = vc[i];    // the vertex color
                        if (i &lt; vp.<a class="code" href="class_array.html#a21">Length</a>()) vert.p = vp[i];            // the vertex parameter
                        return(0);
        }

        // if value arrays are not present or to short, values will not be stored

        virtual int <a class="code" href="class_gshell.html#a71">SetVertex</a>(int i, const <a class="code" href="class_gvertex.html">GVertex</a> &amp;vert)
        {

                        if (i &lt; v.<a class="code" href="class_array.html#a21">Length</a>())   v[i] = vert.v;                    // the vertex coordinates
                        if (i &lt; vn.<a class="code" href="class_array.html#a21">Length</a>()) vn[i] = vert.n;    // the vertex normal
                        if (i &lt; vc.<a class="code" href="class_array.html#a21">Length</a>()) vc[i] = vert.c;    // the vertex color
                        if (i &lt; vp.<a class="code" href="class_array.html#a21">Length</a>()) vp[i] = vert.p;            // the vertex parameter
                        return(0);
        }

        // if values are not present they will not be stored
        virtual int <a class="code" href="class_gshell.html#a72">GetVertexI</a>(int i, <a class="code" href="class_gvertexi.html">GVertexI</a> &amp;vert)
        {

                        if (i &lt; v.<a class="code" href="class_array.html#a21">Length</a>())  vert.v = i;                // the vertex coordinates
                        if (i &lt; vn.<a class="code" href="class_array.html#a21">Length</a>()) vert.n = i;                // the vertex normal
                        if (i &lt; vc.<a class="code" href="class_array.html#a21">Length</a>()) vert.c = i;                // the vertex color
                        if (i &lt; vp.<a class="code" href="class_array.html#a21">Length</a>()) vert.p = i;        // the vertex parameter
                        return(0);
        }

        virtual int <a class="code" href="class_gshell.html#a73">ComputeMaxVertexI</a>( <a class="code" href="class_gvertexi.html">GVertexI</a> &amp;vert);

        virtual <a class="code" href="class_gvertexi.html">GVertexI</a>&amp; <a class="code" href="class_gshell.html#a74">GetMaxI</a>();


        virtual int <a class="code" href="class_gshell.html#a75">CountFaces</a>();

        virtual int <a class="code" href="class_gshell.html#a76">GetFaceCount</a>();

        virtual int <a class="code" href="class_gshell.html#a77">GetFaceList</a>(<a class="code" href="class_gfacelist.html">GFaceList</a> &amp;flist);

        virtual void <a class="code" href="class_gshell.html#a78">ComputeFaceNormals</a>(int allocFaceinfo=0);

        // this normally includes calling compute face normals
        virtual int <a class="code" href="class_gshell.html#a79">ComputeVertexNormals</a>();

        virtual int <a class="code" href="class_gshell.html#a80">FlipNormals</a>();

        int <a class="code" href="class_gshell.html#a81">NormalsFlipped</a>() { return ( flags &amp; SHELL_FLIP_NORMALS) != 0; }

        // compute vertex colors for each vertex from attached faces face color 
        virtual int <a class="code" href="class_gshell.html#a82">ComputeVertexColorsFromFaceColors</a>();

        // compute face colors for each face from average of all face vertex colors 
        virtual int <a class="code" href="class_gshell.html#a83">ComputeFaceColorsFromVertexColors</a>();


        virtual int <a class="code" href="class_gshell.html#a84">ComputeEdgeList</a>();
        
        // Flag handling

        // mark for flat shading 
        void <a class="code" href="class_gshell.html#a85">SetFlat</a>() { flags |= SHELL_SHADE_FLAT;}
        gbool <a class="code" href="class_gshell.html#a86">Flat</a>() { return( (flags &amp; SHELL_SHADE_FLAT) !=0); }
        
        int <a class="code" href="class_gshell.html#a87">SetFlag</a>(int f) { return(flags |=f); }
        
        int <a class="code" href="class_gshell.html#a88">UnSetFlag</a>(int f) { return(flags &amp;= ~f); }

        gbool <a class="code" href="class_gshell.html#a89">GetFlag</a>(int f) { return( (flags &amp; f) !=0); }


        int <a class="code" href="class_gshell.html#a90">SetEditFlag</a>(int f) { return(edit_flags |=f); }

        int <a class="code" href="class_gshell.html#a91">UnSetEditFlag</a>(int f) { return(edit_flags &amp;= ~f); }

        int <a class="code" href="class_gshell.html#a92">SetAction</a>(int f) { return(actions |=f); }
        
        int <a class="code" href="class_gshell.html#a93">UnSetAction</a>(int f) { return(actions &amp;= ~f); }


        void <a class="code" href="class_gobject.html#a0">SetChanged</a>() {<a class="code" href="class_gshell.html#a90">SetEditFlag</a>(SHELL_CHANGED); };

        void <a class="code" href="class_gobject.html#a1">UnSetChanged</a>() { edit_flags = 0; };
        
        int <a class="code" href="class_gobject.html#a2">Changed</a>() { return(edit_flags != 0); }

        /* ! Evaluate object as object of type "type"
          if return = this, don´t destroy result, otherwise destroy */
        virtual GEvalAs_TYPE* <a class="code" href="class_gvnode.html#a62">EvalAs</a>(<a class="code" href="class_typeid.html">TypeId</a> type,int copyAttributes=1); 


          void <a class="code" href="class_gshell.html#a98">Cleanup</a>();

          void <a class="code" href="class_gshell.html#a99">Make</a>(int new_nv,const <a class="code" href="class_point.html">Point</a> *new_v,
                                int new_nf,const int *new_f);


#ifdef _OGL
        // OPENGL Rendering
        virtual void RenderGlFaces(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int FN=1, int VN=0, int VC=0, int VP=0);
        
        // Render primitive list
        virtual void RenderGlPrimitives(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int FN, int VN, int VC, int VP);

        virtual void RenderGlEdges(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int VN=0,int VC=0,int VP=0);
        
        
        virtual void RenderGlVertices(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int VN=0,int           VC=0);


        virtual void RenderGlNormals(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,float scale=0.2,int VN=1,int FN=0);

        virtual void RenderGlBBox(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state);

        virtual int glRender(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state);
#endif

#ifdef _D3D
    virtual int GetVertex(RenderState &amp;state,int flipNormals, D3DVERTEX *V);

        virtual int <a class="code" href="class_gshell.html#a70">GetVertex</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int flipNormals, D3DCVERTEX *V);

        virtual int <a class="code" href="class_gshell.html#a70">GetVertex</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int flipNormals,DWORD flags, D3DCOLOR diffuse, D3DVALUE *V);

        virtual int <a class="code" href="class_gshell.html#a70">GetVertex</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,D3DCOLOR color, D3DCOLOR specular,D3DLVERTEX *V);

        virtual int <a class="code" href="class_gshell.html#a70">GetVertex</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int flipNormals,D3DVERTEX *V,<a class="code" href="class_intarray.html">IntArray</a> &amp;map);

        virtual int <a class="code" href="class_gshell.html#a70">GetVertex</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,D3DCOLOR color, D3DCOLOR specular,D3DLVERTEX *V,<a class="code" href="class_intarray.html">IntArray</a> &amp;map);


    virtual int CreateExBuf(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,<a class="code" href="class_g3objref.html">G3ObjRef</a> &amp;objBuf);


        virtual int CreateExBuf(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,<a class="code" href="class_g3exbuf.html">G3ExBuf</a> &amp;<a class="code" href="class_buf.html">buf</a>);


    int UpdateExBufVerts(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,<a class="code" href="class_g3exbuf.html">G3ExBuf</a> &amp;<a class="code" href="class_buf.html">buf</a>,gbool unlit);

    <a class="code" href="class_g3objref.html">G3ObjRef</a> objBuf;


    
    void ReleaseExBuf() { objBuf.<a class="code" href="class_g3objref.html#a7">Release</a>(); <a class="code" href="class_gshell.html#a92">SetAction</a>(SHELL_COMPUTE_EXBUF); }
    
        int D3dRender(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;traversalState, DWORD mode = D3DEXECUTE_CLIPPED);

        <a class="code" href="class_floatarrayaligned.html">FloatArrayAligned</a>  vtl;

        // TO DO:
        


        <a class="code" href="class_array.html">Array</a>&lt;WORD&gt; primIndex; // DrawPrimitiveIndexed list 

        int nPrim;                      
        int primType;           
        int textureMatrixVersion; 

        gbool isUnlit;          
        D3DCOLOR  currentColorD3D; 

        void TransformLightVertices(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;traversalState, D3DTLVERTEX *vtlp);

        virtual int D3dRenderTL(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;traversalState);

        int CreateVBBuf(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state/*,G3VBBuf &amp;buf*/);

        int UpdateVBBuf(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state);

        virtual int D3dRenderVB(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;traversalState);

        
        <a class="code" href="class_g3vbbufref.html">G3VBBufRef</a> hVBBuf;

        //      DWORD  vertexTypeDesc

#endif

        static int maxSubMeshVertices; 

        // submesh support
        <a class="code" href="class_gsubmesh.html">GSubMesh</a> *subMeshes;    
        
        int <a class="code" href="class_gshell.html#a100">CreateSubMeshes</a>() { return <a class="code" href="class_gshell.html#a100">CreateSubMeshes</a>(maxSubMeshVertices); }

        virtual int <a class="code" href="class_gshell.html#a100">CreateSubMeshes</a>(int maxv);
        
        void <a class="code" href="class_gshell.html#a102">DeleteSubMeshes</a>();

        virtual void <a class="code" href="class_gshell.html#a103">UpdateSubMeshVertices</a>(int what=0);

        // 



        virtual int <a class="code" href="class_gshell.html#a104">ComputePrimitiveList</a>(int flags=0);

#ifdef _3DV

        virtual int ioOutputAttributes(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);

        virtual int ioInputOneAttribute(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);

        virtual int <a class="code" href="class_gattributenode.html#a10">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);

#endif _3DV

        // GClass protocol

        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);
        
        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;state);

        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_gbboxtraversal.html">GBBoxTraversal</a> &amp;state);

        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_grayselecttraversal.html">GRaySelectTraversal</a> &amp;state); // declared in GShell.h implmented in GRaySelect

        <a class="code" href="class_rapid_model.html">RAPID_model</a>* rapidModel;
        
        virtual void <a class="code" href="class_gshell.html#a109">ComputeRapidModel</a>();



    virtual int <a class="code" href="class_gshell.html#a110">IntersectFaces</a>(<a class="code" href="class_grayselecttraversal.html">GRaySelectTraversal</a> &amp;traversal,const <a class="code" href="class_gfacelist.html">GFaceList</a> &amp;f, <a class="code" href="class_rayrange.html">RayRange</a> &amp;ray, <a class="code" href="class_ghitinfo.html">GHitInfo</a> &amp;info); // declared in GShell.h implemented in GRaySelect

        virtual int <a class="code" href="class_gshell.html#a111">CollideFaces</a>(const <a class="code" href="class_gfacelist.html">GFaceList</a> &amp;f, <a class="code" href="class_gconvexvolume.html">GConvexVolume</a> &amp;volume, <a class="code" href="class_gcollisionresponse.html">GCollisionResponse</a> &amp;response, <a class="code" href="class_ghitinfo.html">GHitInfo</a> &amp;hitInfo);


        
        // additional io routines implemented in GShellIO.CPP
#ifdef _HMF
        virtual int WriteHmf(AStream &amp;a);
#endif

#ifdef _GEO
        virtual int WriteGeo(AStream &amp;a,int outputNormals=0);

#endif

#ifdef _STL
        virtual int WriteStl(AStream &amp;a);
#endif

#ifdef _POV
        virtual int WritePov(AStream &amp;a);
#endif

#ifdef _RAW
        virtual int WriteRaw(AStream &amp;a);
#endif

#ifdef _VRML
        virtual int WriteVrml(AStream &amp;a,gbool vrml2);

        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_giotraversal.html">GioTraversal</a> &amp;state); 

#endif

#ifdef _GSTATS
        // information for profiling
        static int  verticesProcessed;  // number of vertics processed
        static int  facesProcessed;             // number of faces processed
        static int  primsProcessed;             //
        static int      trianglesDrawn;         // number of triangles sent to render layer
        static int      facesDrawn;                     // number of faces sent to render layer
        static int  maxPrimVertexCnt;   // size of largest vertex array
        static int  maxPrimTriCnt;              // size of largest vertex array
        static void ClearStats();

#endif


};

//
//@class a 2 d Array of vertices
//
class <a class="code" href="class_gmesh.html">GMesh</a>:public <a class="code" href="class_gshell.html">GShell</a>
{
public:
    <a class="code" href="class_gobject.html#c0">RT</a>(<a class="code" href="class_gshell.html">GShell</a>);
        int ncols /* u */;
    int nrows /* v */;

        int closedU,closedV;    // use only for calculating vertex normals , not implemented 

        <a class="code" href="class_gmesh.html#a1">GMesh</a>(int Nu=0,int Nv=0,const <a class="code" href="class_point.html">Point</a> *p=0) : <a class="code" href="class_gshell.html">GShell</a>() {
                                                                ncols=Nu; nrows=Nv;
                                                                closedU=0;
                                                                closedV=0;
                                                                <a class="code" href="class_gshell.html#a9">SetV</a>(nrows*ncols,p);
                                                                };

    // set mesh to new grid of points
        <a class="code" href="class_gmesh.html">GMesh</a>&amp; <a class="code" href="class_gattributenode.html#a4">Set</a>(int Nu=0,int Nv=0,const <a class="code" href="class_point.html">Point</a> *p=0)  {
                                                                ncols=Nu; nrows=Nv;
                                                                <a class="code" href="class_gshell.html#a9">SetV</a>(nrows*ncols,p);
                                                                return (*this);
                                                                };

        virtual <a class="code" href="class_gshell.html">GShell</a>* <a class="code" href="class_gshell.html#a7">CopyGeometry</a>(<a class="code" href="class_gshell.html">GShell</a> *dest=0) const;

    void <a class="code" href="class_gmesh.html#a4">GetSize</a>(int &amp;Cols,int &amp;Rows) { Cols = ncols; Rows = nrows; }
        void <a class="code" href="class_gmesh.html#a5">SetClosed</a>(int u=0,int v=0) { closedU=u, closedV=v; }
        void <a class="code" href="class_gmesh.html#a6">GetClosed</a>(int &amp;u,int &amp;v) { u=closedU, v=closedV; }

        int <a class="code" href="class_gmesh.html#a7">Map</a>(int u,int v) { return(v*ncols+u); }

        int <a class="code" href="class_gshell.html#a75">CountFaces</a>();

        void <a class="code" href="class_gmesh.html#a9">ComputeFaceList</a>(gbool quads=gtrue);
        
        void <a class="code" href="class_gshell.html#a109">ComputeRapidModel</a>();

        // overwritten virtuals from GShell
        int <a class="code" href="class_gshell.html#a77">GetFaceList</a>(<a class="code" href="class_gfacelist.html">GFaceList</a> &amp;flist);
        int <a class="code" href="class_gshell.html#a76">GetFaceCount</a>();

        int <a class="code" href="class_gshell.html#a67">ComputeTriangles</a>(<a class="code" href="class_gfacelist.html">GFaceList</a> &amp;<a class="code" href="class_tri.html">tri</a>,<a class="code" href="class_intarray.html">IntArray</a> &amp;tri2face,int useTriangulator=0);

        void <a class="code" href="class_gshell.html#a78">ComputeFaceNormals</a>(int allocFaceinfo=0);
        
    int <a class="code" href="class_gshell.html#a79">ComputeVertexNormals</a>();

        // int ComputeEdgeList();


        void <a class="code" href="class_gmesh.html#a16">SetVertexParametersNative</a>(float umin=0.0,float umax=1.0,
                                                                                                                   float vmin=0.0,float vmax=1.0);
        // compute native vertex parameters for object
        void <a class="code" href="class_gshell.html#a69">GetVertexParametersNative</a>(int n,<a class="code" href="class_point.html">Point</a> *vp);

         GEvalAs_TYPE* <a class="code" href="class_gshell.html#a97">EvalAs</a>(<a class="code" href="class_typeid.html">TypeId</a> type,int copyAttributes=1);

    virtual int <a class="code" href="class_gshell.html#a110">IntersectFaces</a>(<a class="code" href="class_grayselecttraversal.html">GRaySelectTraversal</a> &amp;traversal,const <a class="code" href="class_gfacelist.html">GFaceList</a> &amp;f, <a class="code" href="class_rayrange.html">RayRange</a> &amp;ray, <a class="code" href="class_ghitinfo.html">GHitInfo</a> &amp;info); // declared in GShell.h implemented in GRaySelect



#ifdef _OGL
        void RenderGlEdges(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int VN=0,int VC=0,int VP=0);

        void RenderGlFaces(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int FN=1, int VN=0, int VC=0, int VP=0);
#endif

#ifdef _D3D
    virtual int CreateExBuf(RenderState &amp;state,G3ObjRef &amp;objBuf);

    virtual int CreateExBuf(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,<a class="code" href="class_g3exbuf.html">G3ExBuf</a> &amp;<a class="code" href="class_buf.html">buf</a>);

        // create for a subrange 
        int CreateExBuf(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,gbool flip, gbool flipNormals,<a class="code" href="class_g3exbuf.html">G3ExBuf</a> &amp;<a class="code" href="class_buf.html">buf</a>,int row0, int row1, int col0,int col1);
    
        // Get all vertices in D3DVertex format 
    // result = number of vertices stored at *V 
    // V must be the right size 
    virtual int <a class="code" href="class_gshell.html#a70">GetVertex</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int flipNormals,D3DVERTEX *V,int row0, int row1, int col0,int col1);
        
        virtual int <a class="code" href="class_gshell.html#a70">GetVertex</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,D3DCOLOR color, D3DCOLOR specular,D3DLVERTEX *V,int row0, int row1, int col0,int col1);

        virtual int D3dRenderTL(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;traversalState);



#endif

#ifdef _3DV
        int <a class="code" href="class_gattributenode.html#a10">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);
#endif _3DV

        // additional io routines implemented in GShellIO.CPP

#ifdef _HMF
        // write mesh to AStream in HMF format
        int WriteHmf(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);
#endif

#ifdef _VRML
        // write to AStream in VRML format
        virtual int WriteVrml(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>,gbool vrml2);
#endif

};


//@class a single face
class <a class="code" href="class_gpolygon.html">GPolygon</a> : public <a class="code" href="class_gshell.html">GShell</a> {
public :
                <a class="code" href="class_gobject.html#c0">RT</a>(<a class="code" href="class_gshell.html">GShell</a>);
                <a class="code" href="class_gpolygon.html#a1">GPolygon</a>(int np=0, const <a class="code" href="class_point.html">Point</a> *p=0);
};

//@class a polyline with optional facelist 

class <a class="code" href="class_gpolyline.html">GPolyline</a> : public <a class="code" href="class_gshell.html">GShell</a> {
public :
                <a class="code" href="class_gobject.html#c0">RT</a>(<a class="code" href="class_gpolyline.html">GPolyline</a>);
                
                <a class="code" href="class_gpolyline.html#a1">GPolyline</a>(int np=0, const <a class="code" href="class_point.html">Point</a> *p=0);

                <a class="code" href="class_gpolyline.html#a1">GPolyline</a>(int new_nv,const <a class="code" href="class_point.html">Point</a> *new_v,
                                int new_nf,const int *new_f);

                int <a class="code" href="class_gshell.html#a77">GetFaceList</a>(<a class="code" href="class_gfacelist.html">GFaceList</a> &amp;flist);



                int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_grayselecttraversal.html">GRaySelectTraversal</a> &amp;state);

#ifdef _OGL
                // render the faces as LINE_STRIP
                void RenderGlFaces(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int FN, int VN, int VC, int VP);
                int glRender(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state);

#endif
#ifdef _D3D
                virtual int CreateExBuf(RenderState &amp;state,G3ObjRef &amp;objBuf);

                virtual int D3dRenderTL(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;traversalState);

#endif



};

//@class a point set with optional facelist 

class <a class="code" href="class_gpoints.html">GPoints</a> : public <a class="code" href="class_gshell.html">GShell</a> {
public :
                <a class="code" href="class_gobject.html#c0">RT</a>(<a class="code" href="class_gpoints.html">GPoints</a>);
                
                <a class="code" href="class_gpoints.html#a1">GPoints</a>(int np=0, const <a class="code" href="class_point.html">Point</a> *p=0);

                int <a class="code" href="class_gshell.html#a77">GetFaceList</a>(<a class="code" href="class_gfacelist.html">GFaceList</a> &amp;flist);

                int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_grayselecttraversal.html">GRaySelectTraversal</a> &amp;state);

#ifdef _OGL
                // render the faces as LINE_STRIP
                void RenderGlFaces(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int FN, int VN, int VC, int VP);
                int glRender(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state);

#endif
#ifdef _D3D
                // Create execute buffer for shell,
                // result 0 error, 1 ok
                virtual int CreateExBuf(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,<a class="code" href="class_g3objref.html">G3ObjRef</a> &amp;objBuf);

                virtual int D3dRenderTL(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;traversalState);

#endif



};



<a class="code" href="class_gshell.html">GShell</a> * <a class="code" href="gshell.h.html#a1">new_box3d</a>(<a class="code" href="class_gshell.html">GShell</a> *cube=0,float atx=-0.5, float aty=-0.5,float atz=-0.5,
                                        float dx=1.0,float dy=1.0,float dz=1.0);

<a class="code" href="class_gshell.html">GShell</a> * <a class="code" href="gshell.h.html#a2">new_icosahedron</a>(<a class="code" href="class_gshell.html">GShell</a> *icosahedron=0,int doComputeNormals=1);

//int compute_polygon_plane_index(int nverts, const int vindex[],
//                                              const Point *verts, Plane *plane);

inline int <a class="code" href="gshell.h.html#a3">compute_polygon_plane_index</a>(int nverts, const int vindex[],
                                                const <a class="code" href="class_point.html">Point</a> *verts, <a class="code" href="class_plane.html">Plane</a> *plane)
{
                int i;

                /*d*/ <a class="code" href="class_point.html">Point</a> refpt;
                /*d*/<a class="code" href="class_point.html">Point</a> normal;
                
                const <a class="code" href="class_point.html">Point</a> *u, *v;
                
                float len;

                if (nverts &lt;=2) {
                        plane-&gt;n.x = 0;
                        plane-&gt;n.y = 0;
                        plane-&gt;n.z = 1;
                        plane-&gt;d = 0;
                        return 0;
                }
                

                /* compute the polygon normal and a reference Point on
                   the plane. Note that the actual reference Point is
                   refpt / nverts
                */
                normal.<a class="code" href="class_point.html#a9">Zero</a>();
                refpt.<a class="code" href="class_point.html#a9">Zero</a>();

                v = &amp;verts[vindex[0]];

                for(i = nverts-1; i &gt;=0 ; i--) {
                        u = &amp;verts[vindex[i]];

                        //v = &amp;verts[vindex[(i + 1) % nverts]];

                        normal.x += (u-&gt;y - v-&gt;y) * (u-&gt;z + v-&gt;z);
                        normal.y += (u-&gt;z - v-&gt;z) * (u-&gt;x + v-&gt;x);
                        normal.z += (u-&gt;x - v-&gt;x) * (u-&gt;y + v-&gt;y);

                        refpt+= *u;

                        v=u;
                }

                /* normalize the polygon normal to obtain the first
                   three coefficients of the plane equation
                */
                len = normal.<a class="code" href="class_point.html#a13">Len</a>();
                if (len == 0.0) len = 1.0f;
                else len = 1.0f / len;
                
                plane-&gt;n.x = normal.x * len;
                plane-&gt;n.y = normal.y * len;
                plane-&gt;n.z = normal.z * len;
                
                /* compute the last coefficient of the plane equation */
                len *= nverts;
                plane-&gt;d = -DotProd (refpt, normal) * len;  // &lt;&lt;&lt;&lt; check this wrong !!!!!
                return(1);
}

#endif // _GSHELL_H


</div></pre><hr><address><small>Generated at Thu Jan 27 18:45:51 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>
