<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>RenderFlags Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:51:22 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>g3render.h</h1>This is the verbatim text of the g3render.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/
#ifndef _G3Render_
#define _G3Render_





/******************************************************************************
@doc

@module G3Render.h - GLView RenderState classes for Direct 3D |

Copyright (c) 1996-1998 by Holger Grahn
All rights reserved

Purpose:

Classes:

Notes:
        global Macro define _D3D for Direct 3D Support 

Changes:

$Revision: $
$Log: $

        28.03.92 added STARTFLAT Macro to PUT_POLYGON
        02.10.98 Texture &amp; Material handle changes in DX5 done with state buffer, not device2.setRenderState

Todo :

******************************************************************************/



// check for error code and TRACE a message
HRESULT <a class="code" href="g3render.h.html#a56">D3DError_</a>(const char *s,HRESULT error, const char *file, int line);


#ifdef _DEBUG

#define    D3DLASTERROR() HRESULT GLastError=D3D_OK;
#define    D3DError(MSG,RESULT) D3DError_(MSG,RESULT,__FILE__,__LINE__)
#define    D3DCheck(CALL) (((GLastError = CALL) == D3D_OK) ? D3D_OK :D3DError("Call failed",GLastError))

#else

#define     D3DLASTERROR()
#define     D3DError(MSG,RESULT) 0
#define     D3DCheck(CALL) CALL

#endif


// want a right handed coordinate system like ogl
// : projection matrix x-flip and faces are flipped 
#define G3RIGHT_HANDED

// forward 
class <a class="code" href="class_gd3device.html">GD3Device</a>;

//typedef struct _image image;

#include "image.h"

#include "grenderbase.h"


/*
   attribute to be handled
   material 
   texture
   culling
   transform / mult / set

  add instructions to attribute buffer

  flush on draw 


    global
           lights
           fog
           view
           renderModes ..

*/


// convienience 
#define glMaterial G3Material


#define GL_FLAT D3DSHADE_FLAT
#define GL_SMOOTH D3DSHADE_GOURAUD

#define GL_POINT D3DFILL_POINT
#define GL_LINE D3DFILL_WIREFRAME
#define GL_FILL D3DFILL_SOLID

#define GL_MODULATE  D3DTBLEND_MODULATE    
#define GL_DECAL  D3DTBLEND_DECAL      


#define GL_NEVER                          D3DCMP_NEVER
#define GL_LESS                           D3DCMP_LESS
#define GL_EQUAL                          D3DCMP_EQUAL
#define GL_LEQUAL                         D3DCMP_LESSEQUAL
#define GL_GREATER                        D3DCMP_GREATER
#define GL_NOTEQUAL                       D3DCMP_NOTEQUAL
#define GL_GEQUAL                         D3DCMP_GREATEREQUAL
#define GL_ALWAYS                         D3DCMP_ALWAYS



/* PixelFormat */
#define GL_COLOR_INDEX                    0x1900
#define GL_STENCIL_INDEX                  0x1901
#define GL_DEPTH_COMPONENT                0x1902
#define GL_RED                            0x1903
#define GL_GREEN                          0x1904
#define GL_BLUE                           0x1905
#define GL_ALPHA                          0x1906
#define GL_RGB                            0x1907
#define GL_RGBA                           0x1908
#define GL_LUMINANCE                      0x1909
#define GL_LUMINANCE_ALPHA                0x190A

/* BlendingFactorDest */
#define GL_ZERO                           D3DBLEND_ZERO
#define GL_ONE                            D3DBLEND_ONE
#define GL_SRC_COLOR                      D3DBLEND_SRCCOLOR
#define GL_ONE_MINUS_SRC_COLOR            D3DBLEND_INVSRCCOLOR
#define GL_SRC_ALPHA                      D3DBLEND_SRCALPHA
#define GL_ONE_MINUS_SRC_ALPHA            D3DBLEND_INVSRCALPHA
#define GL_DST_ALPHA                      D3DBLEND_DESTALPHA
#define GL_ONE_MINUS_DST_ALPHA            D3DBLEND_INVDESTALPHA

/* BlendingFactorSrc */
/*      GL_ZERO */
/*      GL_ONE */
#define GL_DST_COLOR                      D3DBLEND_DESTCOLOR
#define GL_ONE_MINUS_DST_COLOR            D3DBLEND_INVDESTCOLOR
#define GL_SRC_ALPHA_SATURATE             D3DBLEND_SRCALPHASAT
/*      GL_SRC_ALPHA */
/*      GL_ONE_MINUS_SRC_ALPHA */
/*      GL_DST_ALPHA */
/*      GL_ONE_MINUS_DST_ALPHA */
//    D3DBLEND_BOTHSRCALPHA      = 12,
//    D3DBLEND_BOTHINVSRCALPHA   = 13,

#define GL_DEPTH_BUFFER_BIT               0x00000100
#define GL_ACCUM_BUFFER_BIT               0x00000200
#define GL_STENCIL_BUFFER_BIT             0x00000400
#define GL_COLOR_BUFFER_BIT               0x00004000


#define GLint int
#define GLenum int
#define GLfloat D3DVALUE
#define GLdouble double


// e.g. persp. correction 
#define GL_FASTEST FALSE
#define GL_NICEST TRUE

// standard version
// slow
/*
#define D3DRGB(r, g, b) \
    (0xff000000L | ( ((long)((r) * 255)) &lt;&lt; 16) | (((long)((g) * 255)) &lt;&lt; 8) | (long)((b) * 255))
#define D3DRGBA(r, g, b, a) \
    (   (((long)((a) * 255)) &lt;&lt; 24) | (((long)((r) * 255)) &lt;&lt; 16) \
    |   (((long)((g) * 255)) &lt;&lt; 8) | (long)((b) * 255) \
    )
*/




/*
 * Untransformed/unlit vertices with Vertexe color ++&gt; DX6 !
 */
#define  D3DFVF_CVERTEX (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE | D3DFVF_TEX0)

typedef struct <a class="code" href="class__d3dcvertex.html">_D3DCVERTEX</a> 
{    float x, y, z;        // position        
         float nx, ny, nz;     // normal
     DWORD color;  // diffuse color 
     float tu,    // texture coordinates          tv1;     float tu2,
           tv;
} D3DCVERTEX, *LPD3DCVERTEX;


// Forward

class <a class="code" href="class_gcamera.html">GCamera</a>;
class <a class="code" href="class_matrix.html">Matrix</a>;
class <a class="code" href="class_renderstate.html">RenderState</a>;





// Last D3D error code 
// extern HRESULT GLastError;

class <a class="code" href="class_g3exbufptr.html">G3ExBufPtr</a> {
public:
        LPVOID lpPointer; // write position in current buffer
        LPVOID lpBuffer;  // buffer start 
        size_t size;
        DWORD offset; // instruction start / vertices before
        
        // return lpPointer 
        operator LPVOID &amp;() {return (lpPointer); }      
        
        // return actual written bytes to exbuf
        ULONG <a class="code" href="class_point.html#a14">Length</a>() const { return (ULONG) ((char *)lpPointer - (char*)lpBuffer); }


        // return allocated size 
        size_t <a class="code" href="class_g3exbufptr.html#a2">MaxLength</a>() const { return(size); }
        size_t <a class="code" href="class_g3exbufptr.html#a3">Size</a>() const { return size; }
        
        <a class="code" href="class_g3exbufptr.html#a4">G3ExBufPtr</a>(size_t Size=0,LPVOID buffer = NULL) {
                                size = Size; lpBuffer = lpPointer = buffer;
                                offset = 0;
                        }

        void <a class="code" href="class_g3exbufptr.html#a5">SetSize</a>(size_t Size) { size = Size; }
        
        void <a class="code" href="class_g3exbufptr.html#a6">PUT_OP</a>(BYTE op,BYTE sz, WORD cnt=1) {
                    <a class="code" href="d3dmacs.h.html#a2">PUTD3DINSTRUCTION</a>(op, sz, cnt, lpPointer);
        }
        static size_t <a class="code" href="class_g3exbufptr.html#d0">OP_SIZE</a>()  { return sizeof(D3DINSTRUCTION); }
        
        // store vertices // only at begin of buffer !!!
        void <a class="code" href="class_g3exbufptr.html#a7">PUT_VERTEX</a>(int nVert, const D3DVERTEX *vert) { <a class="code" href="d3dmacs.h.html#a3">VERTEX_DATA</a>((const void *) vert,nVert,lpPointer); offset = <a class="code" href="class_point.html#a14">Length</a>(); }
        static size_t <a class="code" href="class_g3exbufptr.html#d1">VERTEX_SIZE</a>(int nVertex)  { return nVertex * sizeof(D3DVERTEX); }

        void <a class="code" href="class_g3exbufptr.html#a8">PUT_OP_EXIT</a>() { <a class="code" href="d3dmacs.h.html#a21">OP_EXIT</a>(lpPointer); }
        void <a class="code" href="class_g3exbufptr.html#a9">PUT_ALIGN</a>() {
            if (<a class="code" href="d3dmacs.h.html#a22">QWORD_ALIGNED</a>(lpPointer)) {
                        <a class="code" href="d3dmacs.h.html#a20">OP_NOP</a>(lpPointer);
                }
        }

        // render points from start to nPoints
        void <a class="code" href="class_g3exbufptr.html#a10">PUT_OP_POINT_LIST</a>(int start, int nPoints) { <a class="code" href="d3dmacs.h.html#a16">OP_POINT_LIST</a>(start, nPoints,lpPointer); }


        void <a class="code" href="class_g3exbufptr.html#a11">PUT_OP_LINE_LIST</a>(int nLines) { <a class="code" href="d3dmacs.h.html#a14">OP_LINE_LIST</a>(nLines,lpPointer); }
        // must be followed by nLines PUT_LINE

        // size req for OP_TRIANGLE_LIST with n Triangles
        size_t <a class="code" href="class_g3exbufptr.html#a12">LINE_LIST_SIZE</a>(int nLines) {  return sizeof(D3DINSTRUCTION) + nLines * sizeof(D3DLINE); }

    // actual index type is WORD
        void <a class="code" href="class_g3exbufptr.html#a13">PUT_LINE</a>(int p1,int p2)
        {
                        LPD3DLINE t = (LPD3DLINE) lpPointer;

                        //TRACE("IN %d %d  %d  \n",p1,p2);
                        t-&gt;v1 = p1; 
                        t-&gt;v2 = p2;

                        t++;
                        lpPointer = (LPVOID) t;

        }


        void <a class="code" href="class_g3exbufptr.html#a14">PUT_OP_TRIANGLE_LIST</a>(int nTriangles) { <a class="code" href="d3dmacs.h.html#a12">OP_TRIANGLE_LIST</a>(nTriangles,lpPointer); }
        // must be followed by nTriangles PUT_TRIANGLE

        // size req for OP_TRIANGLE_LIST with n Triangles
        size_t <a class="code" href="class_g3exbufptr.html#a15">TRIANGLE_LIST_SIZE</a>(int nTriangles) {  return sizeof(D3DINSTRUCTION) + nTriangles * sizeof(D3DTRIANGLE); }

    // actual index type is WORD
        void <a class="code" href="class_g3exbufptr.html#a16">PUT_TRIANGLE</a>(int p1,int p2, int p3,gbool flip= FALSE)
        {
                        LPD3DTRIANGLE t = (LPD3DTRIANGLE) lpPointer;
            t-&gt;wFlags = D3DTRIFLAG_START | D3DTRIFLAG_EDGEENABLETRIANGLE;

                        //TRACE("IN %d %d  %d  \n",p1,p2,p3);
                        t-&gt;v1 = p1; 
                        if (flip) 
                        { t-&gt;v2 = p3;   t-&gt;v3 = p2; }
                        else { t-&gt;v2 = p2;      t-&gt;v3 = p3; }

                        t++;
                        lpPointer = (LPVOID) t;
                        
        }

        // clear the prev triangle buffer 
        void <a class="code" href="class_g3exbufptr.html#a17">SETUP_PREV</a>(D3DTRIANGLE &amp;prev) 
        {
                prev.v1=prev.v2=prev.v3 =(WORD) -1;
                prev.wFlags = 0;
        }

        // try to build strips with prev triangle
        void <a class="code" href="class_g3exbufptr.html#a16">PUT_TRIANGLE</a>(int p1,int p2, int p3,gbool flip,D3DTRIANGLE &amp;prev)
        {
                        LPD3DTRIANGLE t = (LPD3DTRIANGLE) lpPointer;

                        //TRACE("IN %d %d  %d  \n",p1,p2,p3);
                        t-&gt;v1 = p1; 
                        if (flip) 
                        { 
                                //t-&gt;v2 = p3;   t-&gt;v3 = p2; 
                                t-&gt;v1 = p3; t-&gt;v2 = p2; t-&gt;v3 = p1; // new test  
                        }
                        else { t-&gt;v2 = p2;      t-&gt;v3 = p3; }

                        if (t-&gt;v1 == prev.v1 &amp;&amp; t-&gt;v2 == prev.v3)
                    t-&gt;wFlags = D3DTRIFLAG_EVEN | D3DTRIFLAG_EDGEENABLETRIANGLE;
                        else if (t-&gt;v1 == prev.v3 &amp;&amp; t-&gt;v2 == prev.v2)
                    t-&gt;wFlags = D3DTRIFLAG_ODD | D3DTRIFLAG_EDGEENABLETRIANGLE;
            else t-&gt;wFlags = D3DTRIFLAG_START | D3DTRIFLAG_EDGEENABLETRIANGLE;
                        
                        prev = *t; // save this as current triangle 

                        t++;
                        lpPointer = (LPVOID) t;
                        
        }

    // with flags 
        void <a class="code" href="class_g3exbufptr.html#a19">PUT_TRIANGLE_FLAG</a>(int p1,int p2, int p3,WORD flags /* =D3DTRIFLAG_START | D3DTRIFLAG_EDGEENABLETRIANGLE */)
        {
                        LPD3DTRIANGLE t = (LPD3DTRIANGLE) lpPointer;
            t-&gt;wFlags = flags;
                        //TRACE("IN %d %d  %d  \n",p1,p2,p3);
                        t-&gt;v1 = p1;
                        t-&gt;v2 = p2;
                        t-&gt;v3 = p3;
                        t++;
                        lpPointer = (LPVOID) t;
                        
        }

        void <a class="code" href="class_g3exbufptr.html#a20">PUT_QUAD</a>(int p1,int p2, int p3, int p4,gbool flip= FALSE)
        {

                        if (flip) {
                                <a class="code" href="class_g3exbufptr.html#a20">PUT_QUAD</a>(p1,p4,p3,p2,FALSE);
                                return;
                        }
                        LPD3DTRIANGLE t = (LPD3DTRIANGLE) lpPointer;

            //only need two edges for wireframe, cull next triangle too
            t-&gt;wFlags =   D3DTRIFLAG_START | D3DTRIFLAG_STARTFLAT(1)
                                                | D3DTRIFLAG_EDGEENABLE1 | D3DTRIFLAG_EDGEENABLE2;
        
                        //TRACE("IN %d %d  %d  \n",p1,p2,p3);
                        t-&gt;v1 = p1;
                        t-&gt;v2 = p2;
                        t-&gt;v3 = p3;
                        t++;
            t-&gt;wFlags =         D3DTRIFLAG_EVEN | 
                                                D3DTRIFLAG_EDGEENABLE2 | D3DTRIFLAG_EDGEENABLE3;
                        t-&gt;v1 = p1;
                        t-&gt;v2 = p3;
                        t-&gt;v3 = p4;
                        t++;
                        lpPointer = (LPVOID) t;
        }

        // PUT a quad part of a quadrilateral mesh, optimizable as tristrip
        void <a class="code" href="class_g3exbufptr.html#a21">PUT_QUAD_STRIP</a>(gbool start,int p1,int p2, int p3, int p4,gbool flip= FALSE,gbool bottomEdge = TRUE)
        {

                        if (flip) {
                                <a class="code" href="class_g3exbufptr.html#a21">PUT_QUAD_STRIP</a>(start,p1,p4,p3,p2,FALSE,bottomEdge);
                                return;
                        }
                        LPD3DTRIANGLE t = (LPD3DTRIANGLE) lpPointer;

            //only need two edges for wireframe, cull next triangle too
                        if (start) 
            t-&gt;wFlags =    D3DTRIFLAG_START // FLAT(1)
                                                | D3DTRIFLAG_EDGEENABLE1 | D3DTRIFLAG_EDGEENABLE2;
                        else 
            t-&gt;wFlags =    D3DTRIFLAG_ODD
                                                 | D3DTRIFLAG_EDGEENABLE2;
        
                        //TRACE("IN %d %d  %d  \n",p1,p2,p3);
                        t-&gt;v1 = p1;
                        t-&gt;v2 = p2;
                        t-&gt;v3 = p3;
                        t++;
            t-&gt;wFlags = D3DTRIFLAG_EVEN | D3DTRIFLAG_EDGEENABLE2;

                        if (bottomEdge) t-&gt;wFlags |= D3DTRIFLAG_EDGEENABLE3;

                        t-&gt;v1 = p1;
                        t-&gt;v2 = p3;
                        t-&gt;v3 = p4;
                        t++;
                        lpPointer = (LPVOID) t;
        }



        // puts n-2 TRIANGLES
        void <a class="code" href="class_g3exbufptr.html#a22">PUT_POLYGON</a>(int n, const int* fp,gbool flip= FALSE)
        {
                        LPD3DTRIANGLE t = (LPD3DTRIANGLE) lpPointer;

            WORD flags = D3DTRIFLAG_START | D3DTRIFLAG_EDGEENABLE1 | D3DTRIFLAG_EDGEENABLE2;


                        if (n&lt;32)
                          flags |= D3DTRIFLAG_STARTFLAT(n-3);
                        else 
                          flags |= D3DTRIFLAG_STARTFLAT(32-3); // could optimize in between

                        // start flat n
                        if (flip) {
                        fp+=n-1;
                        int p1=*fp--, p2=*fp--;
                        n-=2;
                        while (n&gt;0) {
                                int p3 = *fp--;
                                n--;
                            if (n==0) flags |= D3DTRIFLAG_EDGEENABLE3;
                                //TRACE("IN %d %d  %d  \n",p1,p2,p3);
                                t-&gt;wFlags = flags;
                                t-&gt;v1 = p1; t-&gt;v2 = p2; t-&gt;v3 = p3;
                                p2=p3;
                                t++;
                                flags = D3DTRIFLAG_EVEN |  D3DTRIFLAG_EDGEENABLE2 ;
                        }
                        }
                        else  {  // no flip
                        int p1=*fp++, p2=*fp++;
                        n-=2;
                        while (n&gt;0) {
                                int p3 = *fp++;
                                n--;
                            if (n==0) flags |= D3DTRIFLAG_EDGEENABLE3;
                                //TRACE("IN %d %d  %d  \n",p1,p2,p3);
                                t-&gt;wFlags = flags;
                                t-&gt;v1 = p1; t-&gt;v2 = p2; t-&gt;v3 = p3;
                                p2=p3;
                                t++;
                   
                                flags =  D3DTRIFLAG_EVEN  | D3DTRIFLAG_EDGEENABLE2 ;

                        }
                        } // no flip

                        lpPointer = (LPVOID) t;
        }

        // puts n-2 TRIANGLES stripped 
        void <a class="code" href="class_g3exbufptr.html#a22">PUT_POLYGON</a>(int n, const int* fp,gbool flip,D3DTRIANGLE &amp;prev)
        {
                        LPD3DTRIANGLE t = (LPD3DTRIANGLE) lpPointer;

            WORD flags = D3DTRIFLAG_START | D3DTRIFLAG_EDGEENABLE1 | D3DTRIFLAG_EDGEENABLE2;


                        if (n&lt;32)
                          flags |= D3DTRIFLAG_STARTFLAT(n-3);
                        else 
                          flags |= D3DTRIFLAG_STARTFLAT(32-3); // could optimize in between

                        // start flat n
                        if (flip) {
                                fp+=n-1;
                                int p1=*fp--, p2=*fp--;
                                n-=2;
                                
                                if (p1 == prev.v1 &amp;&amp; p2 == prev.v3)
                                        flags |= D3DTRIFLAG_EVEN ;
                                else if (p1 == prev.v3 &amp;&amp; p2 == prev.v2)
                                        flags |= D3DTRIFLAG_ODD ;

                        while (n&gt;0) {
                                int p3 = *fp--;
                                n--;
                            if (n==0) flags |= D3DTRIFLAG_EDGEENABLE3;
                                //TRACE("IN %d %d  %d  \n",p1,p2,p3);
                                t-&gt;wFlags = flags;
                                t-&gt;v1 = p1; t-&gt;v2 = p2; t-&gt;v3 = p3;
                                p2=p3;
                                t++;
                                flags = D3DTRIFLAG_EVEN |  D3DTRIFLAG_EDGEENABLE2 ;
                        }
                        }
                        else  {  // no flip
                                int p1=*fp++, p2=*fp++;
                                n-=2;

                                if (p1 == prev.v1 &amp;&amp; p2 == prev.v3)
                                        flags |= D3DTRIFLAG_EVEN ;
                                else if (p1 == prev.v3 &amp;&amp; p2 == prev.v2)
                                        flags |= D3DTRIFLAG_ODD ;

                        while (n&gt;0) {
                                int p3 = *fp++;
                                n--;
                            if (n==0) flags |= D3DTRIFLAG_EDGEENABLE3;
                                //TRACE("IN %d %d  %d  \n",p1,p2,p3);
                                t-&gt;wFlags = flags;
                                t-&gt;v1 = p1; t-&gt;v2 = p2; t-&gt;v3 = p3;
                                p2=p3;
                                t++;
                   
                                flags =  D3DTRIFLAG_EVEN  | D3DTRIFLAG_EDGEENABLE2 ;

                        }
                        } // no flip
                        
                        prev = t[-1];

                        lpPointer = (LPVOID) t;
        }


        // puts n-1 LINES
        void <a class="code" href="class_g3exbufptr.html#a24">PUT_POLYLINE</a>(int n, const int* fp,gbool flip= FALSE)
        {
                        LPD3DLINE t = (LPD3DLINE) lpPointer;

                        if (flip) {
                        fp+=n-1;
                        int p1=*fp--;
                        n-=1;
                        while (n&gt;0) {
                                int p2 = *fp--;
                                n--;
                                //TRACE("IN %d %d  %d  \n",p1,p2);
                                t-&gt;v1 = p1; t-&gt;v2 = p2; 
                                p1=p2;
                                t++;
                        }
                        }
                        else  {  // no flip
                        int p1=*fp++;
                        n-=1;
                        while (n&gt;0) {
                                int p2 = *fp++;
                                n--;
                                //TRACE("IN %d %d  %d  \n",p1,p2,p3);
                                t-&gt;v1 = p1; t-&gt;v2 = p2;
                                p1=p2;
                                t++;
                        }
                        } // no flip

                        lpPointer = (LPVOID) t;
        }


        gbool <a class="code" href="class_point.html#a6">Set</a>(int nV, D3DVERTEX *v,int nTri, D3DTRIANGLE *<a class="code" href="class_tri.html">tri</a>);

    // set texture wrapping mode
        void <a class="code" href="class_g3exbufptr.html#a26">put_texture_wrap</a>(gbool wrap_s,gbool wrap_t) {
                <a class="code" href="d3dmacs.h.html#a8">OP_STATE_RENDER</a>(2, lpPointer);
            <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(D3DRENDERSTATE_WRAPU, wrap_s, lpPointer);
            <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(D3DRENDERSTATE_WRAPV, wrap_t, lpPointer);
        }
        
    // set texture handle 
    void <a class="code" href="class_g3exbufptr.html#a27">put_texture_handle</a>(D3DTEXTUREHANDLE hTex) {
                <a class="code" href="d3dmacs.h.html#a8">OP_STATE_RENDER</a>(1, lpPointer);
            <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(D3DRENDERSTATE_TEXTUREHANDLE, hTex, lpPointer);
        }

};


/*
  G3ExBuf

  G3ExBuf b;
  b.Create(lpD3DDevice, mysize);
  b.Lock()
     // write data
  b.Unlock();
  b.Set();
  b.Execute();

*/

class <a class="code" href="class_g3exbuf.html">G3ExBuf</a> : public <a class="code" href="class_g3exbufptr.html">G3ExBufPtr</a> {
public:
    LPDIRECT3DEXECUTEBUFFER lpD3DExBuf;  

        // only set size 
        <a class="code" href="class_g3exbuf.html#a0">G3ExBuf</a>(size_t Size=0) : <a class="code" href="class_g3exbufptr.html">G3ExBufPtr</a>(Size) { lpD3DExBuf = NULL; }
        
        // set size and create 
        <a class="code" href="class_g3exbuf.html#a0">G3ExBuf</a>(LPDIRECT3DDEVICE lpD3DDevice, size_t Size) : <a class="code" href="class_g3exbufptr.html">G3ExBufPtr</a>(Size) 
        {       lpD3DExBuf = NULL; 
                <a class="code" href="class_g3exbuf.html#a4">Create</a>(lpD3DDevice); 
        }
        <a class="code" href="class_g3exbuf.html#a2">~G3ExBuf</a>() { <a class="code" href="class_g3exbuf.html#a10">Release</a>(); }

    gbool <a class="code" href="class_g3exbuf.html#a3">Ok</a>() { return(lpD3DExBuf != NULL); } 

    // create the buffer using the current size 
        gbool <a class="code" href="class_g3exbuf.html#a4">Create</a> (LPDIRECT3DDEVICE lpD3DDevice) {
        <a class="code" href="class_g3exbuf.html#a10">Release</a>();
                
                HRESULT GLastError;

        D3DEXECUTEBUFFERDESC debDesc;
                memset(&amp;debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
                debDesc.dwSize = sizeof(D3DEXECUTEBUFFERDESC);
                debDesc.dwFlags = D3DDEB_BUFSIZE;
                // caps : video / system
                debDesc.dwBufferSize = size;
                
                GLastError = lpD3DDevice-&gt;CreateExecuteBuffer(&amp;debDesc, &amp;lpD3DExBuf, NULL);
        if (GLastError != D3D_OK)  <a class="code" href="g3render.h.html#a1">D3DError</a>("CreateExecuteBuffer failed",GLastError);

        return (GLastError == D3D_OK);
        }

    // create the buffer using the  new size 

        gbool <a class="code" href="class_g3exbuf.html#a4">Create</a> (LPDIRECT3DDEVICE lpD3DDevice, size_t newSize) {
        <a class="code" href="class_g3exbuf.html#a10">Release</a>();
                <a class="code" href="class_g3exbufptr.html#a5">SetSize</a>(newSize);
                return <a class="code" href="class_g3exbuf.html#a4">Create</a>(lpD3DDevice);
        }

        // lock the buffer, to enable writing
        gbool <a class="code" href="class_g3exbuf.html#a6">Lock</a>() {
                HRESULT GLastError;
                D3DEXECUTEBUFFERDESC debDesc;
                memset(&amp;debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
                debDesc.dwSize = sizeof(D3DEXECUTEBUFFERDESC);
                GLastError = lpD3DExBuf-&gt;Lock(&amp;debDesc);
        if (GLastError == D3D_OK) {
                    lpPointer = lpBuffer = debDesc.lpData;
            size = debDesc.dwBufferSize;
        } else {
          <a class="code" href="g3render.h.html#a1">D3DError</a>("LockExecuteBuffer failed",GLastError);
        }
        return (GLastError == D3D_OK);
        }

        // unlock buffer 
        gbool <a class="code" href="class_g3exbuf.html#a7">Unlock</a>() {
                HRESULT GLastError;
                GLastError = lpD3DExBuf-&gt;Unlock();
        if (GLastError != D3D_OK)  <a class="code" href="g3render.h.html#a1">D3DError</a>("UnlockExecuteBuffer failed",GLastError);
        return (GLastError == D3D_OK);
        }
        

        // set the execute buffer data
    // length is current lpPointer-
    // execute the buffer  release buffer (After Create + Lock/Unlock)

        gbool <a class="code" href="class_g3exbufptr.html#a25">Set</a>() {
                HRESULT GLastError;
                D3DEXECUTEDATA d3dExData;
                // memset(&amp;d3dExData, 0, sizeof(D3DEXECUTEDATA));
                d3dExData.dwSize = sizeof(D3DEXECUTEDATA);
                d3dExData.dwVertexOffset = 0;
                d3dExData.dwVertexCount = offset / sizeof(D3DVERTEX);
                d3dExData.dwInstructionOffset = offset;
                d3dExData.dwInstructionLength = <a class="code" href="class_g3exbufptr.html#a1">Length</a>() - offset;
                d3dExData.dwHVertexOffset=
                d3dExData.dsStatus.dwFlags=d3dExData.dsStatus.dwStatus =0; // new 

                GLastError = lpD3DExBuf-&gt;SetExecuteData(&amp;d3dExData);
        if (GLastError != D3D_OK)  <a class="code" href="g3render.h.html#a1">D3DError</a>("SetExecuteData failed",GLastError);
        return (GLastError == D3D_OK);
        }

        gbool <a class="code" href="class_g3exbuf.html#a9">Execute</a>(LPDIRECT3DDEVICE lpDev, LPDIRECT3DVIEWPORT lpView, DWORD mode = D3DEXECUTE_UNCLIPPED)
        {
                HRESULT GLastError;
                GLastError = lpDev-&gt;Execute(lpD3DExBuf, lpView, mode);
        if (GLastError != D3D_OK)  <a class="code" href="g3render.h.html#a1">D3DError</a>("ExecuteData failed",GLastError);
        return (GLastError == D3D_OK);
        }
        
        void <a class="code" href="class_g3exbuf.html#a10">Release</a>() 
        {
                HRESULT GLastError;
                if (lpD3DExBuf)
                   GLastError = lpD3DExBuf-&gt;Release();
                lpPointer = lpBuffer = NULL;
                lpD3DExBuf = NULL;
        }


    // clear buffer to zero (After Lock)
    void <a class="code" href="class_g3exbuf.html#a11">ClearAndZero</a>() {
                memset(lpBuffer, 0, size);
                lpPointer = lpBuffer;
        }

    void <a class="code" href="class_g3exbuf.html#a12">Clear</a>() {
                lpPointer = lpBuffer;
        }

};

class <a class="code" href="class_g3exbufdesc.html">G3ExBufDesc</a> : public <a class="code" href="class_g3exbuf.html">G3ExBuf</a> {
public:

    D3DEXECUTEBUFFERDESC debDesc;

        // only set size 
        <a class="code" href="class_g3exbufdesc.html#a0">G3ExBufDesc</a>(size_t Size=0) : <a class="code" href="class_g3exbuf.html">G3ExBuf</a>(Size) {  
                memset(&amp;debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
                debDesc.dwSize = sizeof(D3DEXECUTEBUFFERDESC);

        }
        
        // set size and create 
        <a class="code" href="class_g3exbufdesc.html#a0">G3ExBufDesc</a>(LPDIRECT3DDEVICE lpD3DDevice, size_t Size) : <a class="code" href="class_g3exbuf.html">G3ExBuf</a>(Size) 
        {        
                memset(&amp;debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
                debDesc.dwSize = sizeof(D3DEXECUTEBUFFERDESC);
                <a class="code" href="class_g3exbuf.html#a4">Create</a>(lpD3DDevice); 
        }
        <a class="code" href="class_g3exbufdesc.html#a2">~G3ExBufDesc</a>() { <a class="code" href="class_g3exbuf.html#a10">Release</a>(); }

    gbool <a class="code" href="class_g3exbuf.html#a3">Ok</a>() { return(lpD3DExBuf != NULL); } 

    // create the buffer using the current size 
        gbool <a class="code" href="class_g3exbuf.html#a4">Create</a>(LPDIRECT3DDEVICE lpD3DDevice) {

                HRESULT GLastError;
        <a class="code" href="class_g3exbuf.html#a10">Release</a>();

                debDesc.dwFlags = D3DDEB_BUFSIZE;
                // caps : video / system
                debDesc.dwBufferSize = size;
                GLastError = lpD3DDevice-&gt;CreateExecuteBuffer(&amp;debDesc, &amp;lpD3DExBuf, NULL);
        if (GLastError != D3D_OK)  <a class="code" href="g3render.h.html#a1">D3DError</a>("CreateExecuteBuffer failed",GLastError);

        return (GLastError == D3D_OK);
        }

    // create the buffer using the  new size 

        gbool <a class="code" href="class_g3exbuf.html#a4">Create</a> (LPDIRECT3DDEVICE lpD3DDevice, size_t newSize) {
        <a class="code" href="class_g3exbuf.html#a10">Release</a>();
                <a class="code" href="class_g3exbufptr.html#a5">SetSize</a>(newSize);
                return <a class="code" href="class_g3exbuf.html#a4">Create</a>(lpD3DDevice);
        }

        // lock the buffer, to enable writing
        gbool <a class="code" href="class_g3exbuf.html#a6">Lock</a>() {
                HRESULT GLastError;
                GLastError = lpD3DExBuf-&gt;Lock(&amp;debDesc);
        if (GLastError == D3D_OK) {
                    lpPointer = lpBuffer = debDesc.lpData;
            size = debDesc.dwBufferSize;
        } else {
          <a class="code" href="g3render.h.html#a1">D3DError</a>("LockExecuteBuffer failed",GLastError);
        }
        return (GLastError == D3D_OK);
        }

        // unlock buffer 
        gbool <a class="code" href="class_g3exbuf.html#a7">Unlock</a>() {
                HRESULT GLastError;
                GLastError = lpD3DExBuf-&gt;Unlock();
        if (GLastError != D3D_OK)  <a class="code" href="g3render.h.html#a1">D3DError</a>("UnlockExecuteBuffer failed",GLastError);
        return (GLastError == D3D_OK);
        }
        

        // set the execute buffer data
    // length is current lpPointer-
    // execute the buffer  release buffer (After Create + Lock/Unlock)

        gbool <a class="code" href="class_g3exbuf.html#a8">Set</a>() {
                HRESULT GLastError;

                D3DEXECUTEDATA d3dExData;
                // memset(&amp;d3dExData, 0, sizeof(D3DEXECUTEDATA));
                d3dExData.dwSize = sizeof(D3DEXECUTEDATA);
                d3dExData.dwVertexOffset = 0;
                d3dExData.dwVertexCount = offset / sizeof(D3DVERTEX);
                d3dExData.dwInstructionOffset = offset;
                d3dExData.dwInstructionLength = <a class="code" href="class_g3exbufptr.html#a1">Length</a>() - offset;
                d3dExData.dwHVertexOffset=0;
                GLastError = lpD3DExBuf-&gt;SetExecuteData(&amp;d3dExData);
        if (GLastError != D3D_OK)  <a class="code" href="g3render.h.html#a1">D3DError</a>("SetExecuteData failed",GLastError);
        return (GLastError == D3D_OK);
        }

    // execute the buffer  release buffer (After Create + Lock/Unlock)
        gbool <a class="code" href="class_g3exbuf.html#a9">Execute</a>(LPDIRECT3DDEVICE lpDev, LPDIRECT3DVIEWPORT lpView, DWORD mode = D3DEXECUTE_UNCLIPPED)
        {
                HRESULT GLastError;
                GLastError = lpDev-&gt;Execute(lpD3DExBuf, lpView, mode);
        if (GLastError != D3D_OK)  <a class="code" href="g3render.h.html#a1">D3DError</a>("ExecuteData failed",GLastError);
        return (GLastError == D3D_OK);
        }
        
    // release buffer (After Unlock)
        void <a class="code" href="class_g3exbuf.html#a10">Release</a>() 
        {
                HRESULT GLastError;
                if (lpD3DExBuf)
                   GLastError = lpD3DExBuf-&gt;Release();
                lpPointer = lpBuffer = NULL;
                lpD3DExBuf = NULL;
        }


    // clear buffer to zero (After Lock)
    void <a class="code" href="class_g3exbuf.html#a11">ClearAndZero</a>() {
                memset(lpBuffer, 0, size);
                lpPointer = lpBuffer;
        }

    void <a class="code" href="class_g3exbuf.html#a12">Clear</a>() {
                lpPointer = lpBuffer;
        }

};

//------------------------//------------------------//------------------------
//                                                              G3VBBufHandle
//------------------------//------------------------//------------------------ 
//
//
// @class maintains a device-independend handle to a device dependend G3VBBuf
// 
// 
class <a class="code" href="class_g3vbbufhandle.html">G3VBBufHandle</a> 
{
public: 

    int refCnt;                         // how many scene nodes are using this buffer
    <a class="code" href="class_g3vbbufhandle.html">G3VBBufHandle</a> *next;    // Double link to from list of all materials in use
    <a class="code" href="class_g3vbbufhandle.html">G3VBBufHandle</a> *prev;

        // only set size 
//      G3VBBufHandle(size_t Size=0) : G3VBBuf(Size) { refCnt = 0; next = prev = NULL;}
        
        // set size and create 
        <a class="code" href="class_g3vbbufhandle.html#a0">G3VBBufHandle</a>() 
        {       
                refCnt = 0; next = prev = NULL; lpD3DVBBuf= NULL;
        }
        
        <a class="code" href="class_g3vbbufhandle.html#a1">~G3VBBufHandle</a>() 
        { 
                HRESULT GLastError;
                if (lpD3DVBBuf)
                   GLastError = lpD3DVBBuf-&gt;Release();
        }

        gbool <a class="code" href="class_g3exbuf.html#a3">Ok</a>() {return lpD3DVBBuf!=NULL;};

        // release buffer (After Unlock)
        void <a class="code" href="class_g3vbbufhandle.html#a3">ReleaseBuffer</a>() 
        {
                HRESULT GLastError;
                <a class="code" href="grmaplay.h.html#a0">TRACE</a>("delete VB\n");
                if (lpD3DVBBuf)
                   GLastError = lpD3DVBBuf-&gt;Release();
                lpD3DVBBuf = NULL;
        }

    void <a class="code" href="class_g3vbbufhandle.html#a4">AddRef</a>() { refCnt++; }

        // release refCnt, can"t delte here because of the linked list 
    ULONG <a class="code" href="class_g3exbuf.html#a10">Release</a>() { refCnt--;  if (refCnt == 0) {<a class="code" href="class_g3vbbufhandle.html#a3">ReleaseBuffer</a>(); return 0;} return refCnt;}



    LPDIRECT3DVERTEXBUFFER lpD3DVBBuf;
        D3DVERTEXBUFFERDESC vbdesc;//or use HRESULT GetVertexBufferDesc(LPD3DVERTEXBUFFERDESC lpVBDesc); 

};



//------------------------//------------------------//------------------------
//                                                                      G3VBBufRef
//------------------------//------------------------//------------------------
/* 
        abstract handle,
        
          holds a pointer to a G3VBBufHandle
*/

class <a class="code" href="class_g3vbbufref.html">G3VBBufRef</a>
{

protected:

public:

    <a class="code" href="class_g3vbbufhandle.html">G3VBBufHandle</a> *handle;

public:

    <a class="code" href="class_g3vbbufref.html#a0">G3VBBufRef</a>(<a class="code" href="class_g3vbbufhandle.html">G3VBBufHandle</a> *newHandle=NULL) 
        { 
                handle = newHandle; 
                if (handle) handle-&gt;<a class="code" href="class_g3vbbufhandle.html#a4">AddRef</a>();
        };
    
    gbool <a class="code" href="class_g3exbuf.html#a3">Ok</a>() { return (handle &amp;&amp; handle-&gt;<a class="code" href="class_g3vbbufhandle.html#a2">Ok</a>()); }
    
    void <a class="code" href="class_g3exbuf.html#a10">Release</a>() {
        if (handle) 
                        handle-&gt;<a class="code" href="class_g3vbbufhandle.html#a5">Release</a>();
        handle = NULL;
    }
        void <a class="code" href="class_g3vbbufref.html#a3">Attach</a>(<a class="code" href="class_g3vbbufhandle.html">G3VBBufHandle</a> *newHandle) 
        { 
        if (handle) 
                        handle-&gt;<a class="code" href="class_g3vbbufhandle.html#a5">Release</a>();
                handle = newHandle; 
                ASSERT(handle);
                handle-&gt;<a class="code" href="class_g3vbbufhandle.html#a4">AddRef</a>();
        };

        //operator G3VBBufHandle&amp; () { return *handle; }

    <a class="code" href="class_g3vbbufref.html#a4">~G3VBBufRef</a>() {
        if (handle) 
                        handle-&gt;<a class="code" href="class_g3vbbufhandle.html#a5">Release</a>();
    }

    friend class <a class="code" href="class_renderstate.html">RenderState</a>;
};






//------------------------//------------------------//------------------------
//                                                                      G3ExBufHandle
//------------------------//------------------------//------------------------
//

class <a class="code" href="class_g3exbufhandle.html">G3ExBufHandle</a> :public <a class="code" href="class_g3exbuf.html">G3ExBuf</a> {
public: 

    int refCnt;                         
    <a class="code" href="class_g3exbufhandle.html">G3ExBufHandle</a> *next;    // Double link to from list of all materials in use
    <a class="code" href="class_g3exbufhandle.html">G3ExBufHandle</a> *prev;

        // only set size 
        <a class="code" href="class_g3exbufhandle.html#a0">G3ExBufHandle</a>(size_t Size=0) : <a class="code" href="class_g3exbuf.html">G3ExBuf</a>(Size) { refCnt = 0; next = prev = NULL;}
        
        // set size and create 
        <a class="code" href="class_g3exbufhandle.html#a0">G3ExBufHandle</a>(LPDIRECT3DDEVICE lpD3DDevice, size_t Size) : <a class="code" href="class_g3exbuf.html">G3ExBuf</a>(lpD3DDevice,Size) 
        {       
                refCnt = 0; next = prev = NULL;
        }
        
        <a class="code" href="class_g3exbufhandle.html#a2">~G3ExBufHandle</a>() { <a class="code" href="class_g3exbuf.html#a10">Release</a>(); }

    void <a class="code" href="class_g3exbufhandle.html#a3">Ref</a>() { refCnt++; }
    void <a class="code" href="class_g3exbufhandle.html#a4">UnRef</a>() { refCnt--;  if (refCnt == 0) <a class="code" href="class_g3exbuf.html#a10">Release</a>(); }

};

//
// G3ExBufRef
//
// holds a pointer to a G3ExBufHandle

class <a class="code" href="class_g3exbufref.html">G3ExBufRef</a>
{

protected:

public:

    <a class="code" href="class_g3exbufhandle.html">G3ExBufHandle</a> *handle;

public:

    <a class="code" href="class_g3exbufref.html#a0">G3ExBufRef</a>() : handle(NULL) { };
    
        // is ExBuf handle valid or need to redefine ?
    gbool <a class="code" href="class_g3exbuf.html#a3">Ok</a>() { return (handle &amp;&amp; handle-&gt;<a class="code" href="class_g3exbuf.html#a3">Ok</a>()); }
    
    void <a class="code" href="class_g3exbuf.html#a10">Release</a>() {
        if (handle) handle-&gt;<a class="code" href="class_g3exbufhandle.html#a4">UnRef</a>();
        handle = NULL;
    }

        operator <a class="code" href="class_g3exbuf.html">G3ExBuf</a>&amp; () { return *handle; }

    // execute the buffer  release buffer (After Create + Lock/Unlock)
        gbool <a class="code" href="class_g3exbuf.html#a9">Execute</a>(LPDIRECT3DDEVICE lpDev, LPDIRECT3DVIEWPORT lpView, DWORD mode = D3DEXECUTE_UNCLIPPED)
        { return handle-&gt;<a class="code" href="class_g3exbuf.html#a9">Execute</a>(lpDev,lpView,mode); }

    // Notify handle (owned by renderstate) that this ref doesn´t need the handle any more
    <a class="code" href="class_g3exbufref.html#a5">~G3ExBufRef</a>() {
        if (handle) handle-&gt;<a class="code" href="class_g3exbufhandle.html#a4">UnRef</a>();
        handle = NULL;
    }

    friend class <a class="code" href="class_renderstate.html">RenderState</a>;
};


#if 0

//@class D3D Red Green Blue Alpha color
class <a class="code" href="class_rgbacolor.html">RGBAColor</a> : public D3DCOLORVALUE {
public:

    //@cmember the color components (range 0..1)

        <a class="code" href="class_rgbacolor.html#a0">RGBAColor</a>(float R=0.0,float G=0.0, float B=0.0,float A=1.0) { r=R,g=G,b=B,<a class="code" href="class_a.html">a</a>=A; };
        <a class="code" href="class_rgbacolor.html#a0">RGBAColor</a>(const <a class="code" href="class_point.html">Point</a> &amp;p,float A=1.0) { r=p.x,g=p.y,b=p.z,<a class="code" href="class_a.html">a</a>=A; };
        <a class="code" href="class_rgbacolor.html#a0">RGBAColor</a>(const D3DCOLORVALUE &amp;c) { * ((D3DCOLORVALUE*) this) = c; };

        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; <a class="code" href="class_g3exbuf.html#a8">Set</a>(float R,float G, float B,float A=1.0) { r=R,g=G,b=B,<a class="code" href="class_a.html">a</a>=A; return(*this); };

        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; <a class="code" href="class_g3exbuf.html#a8">Set</a>(const <a class="code" href="class_point.html">Point</a> &amp;p,float A=1.0) { r=p.x,g=p.y,b=p.z,<a class="code" href="class_a.html">a</a>=A; return(*this); };
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; <a class="code" href="class_rgbacolor.html#a4">Get</a>(<a class="code" href="class_point.html">Point</a> &amp;p) { p.<a class="code" href="class_point.html#a6">Set</a>(r,g,b); return(*this); };
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; <a class="code" href="class_rgbacolor.html#a5">SetAlpha</a>(float A=1.0) { <a class="code" href="class_a.html">a</a>=A; return(*this); };

        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; <a class="code" href="class_rgbacolor.html#a6">White</a>() { r=g=b=1.0; <a class="code" href="class_a.html">a</a>=1.0; return (*this); };
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; <a class="code" href="class_rgbacolor.html#a7">Black</a>() { r=g=b=0.0; <a class="code" href="class_a.html">a</a>=1.0; return (*this); };
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; <a class="code" href="class_rgbacolor.html#a8">Gray</a>(float gray) { r=g=b=gray; <a class="code" href="class_a.html">a</a>=1.0; return (*this);};

        // convert to packed color format
        operator D3DCOLOR() const { return(D3DRGBA_X(r, g, b,<a class="code" href="class_a.html">a</a> )); } 

        operator float* () {return &amp;r;};                // type convert to float * (float[4]) 
        // input/ouput
        int <a class="code" href="class_point.html#a38">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>,int fmt=0);
        // Unary operators returning a new RGBAColor
        <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator- () const;
        <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator+ () const;


        // Assignment operators
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; operator+= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A);
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; operator-= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A);
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; operator*= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A);
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; operator/= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A);
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; operator+= (float A);
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; operator-= (float A);
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; operator*= (float A);
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; operator/= (float A);

        // Binary operators returning a new RGBAColor
        friend <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator+ (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B);
        friend <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator- (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B);
        friend <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator* (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B);
        friend <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator* (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, float B);
        friend <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator* (float A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B);
        friend <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator* (const <a class="code" href="class_matrix.html">Matrix</a>&amp;, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp;);
        friend <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator/ (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B);
        friend <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator/ (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, float B);

        friend int operator&lt; (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B);



};

// io to AStream 
int io(D3DCOLORVALUE &amp;this_,<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>,int fmt=0);

// set color to a gray value
void SetGray(D3DCOLORVALUE &amp;v, float gray,float alpha=1.0);

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> RGBAColor::operator+ () const
{
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> RGBAColor::operator- () const
{
        return RGBAColor(-r, -g, -b, -<a class="code" href="class_a.html">a</a>);
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; RGBAColor::operator+= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A)
{
        r += A.r;  g += A.g; b += A.b; <a class="code" href="class_a.html">a</a> += A.a;
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; RGBAColor::operator-= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A)
{
        r -= A.r;  g -= A.g; b -= A.b; <a class="code" href="class_a.html">a</a> -= A.a;
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; RGBAColor::operator+= (float A)
{
        r += A;  g += A;  b += A;  <a class="code" href="class_a.html">a</a> += A;
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; RGBAColor::operator-= (float A)
{
        r -= A;  g -= A;  b -= A;  <a class="code" href="class_a.html">a</a> -= A;
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; RGBAColor::operator*= (float A)
{
        r *= A;  g *= A;  b *= A; <a class="code" href="class_a.html">a</a> *= A;
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; RGBAColor::operator/= (float A)
{
        r /= A;  g /= A;  b /= A; <a class="code" href="class_a.html">a</a> /= A;
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; RGBAColor::operator*= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A)
{
        r *= A.r;  g *= A.g;  b *= A.b; <a class="code" href="class_a.html">a</a> *= A.a;
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; RGBAColor::operator/= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A)
{
        r /= A.r;  g /= A.g;  b /= A.b;  <a class="code" href="class_a.html">a</a> /= A.a;
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator+ (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B)
{
        return RGBAColor(A.r + B.r, A.g + B.g, A.b + B.b, A.<a class="code" href="class_a.html">a</a> + B.<a class="code" href="class_a.html">a</a>);
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator- (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B)
{
        return RGBAColor(A.r - B.r, A.g - B.g, A.b - B.b , A.<a class="code" href="class_a.html">a</a> - B.<a class="code" href="class_a.html">a</a>);
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator* (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B)
{
        return RGBAColor(A.r * B.r, A.g * B.g, A.b * B.b, A.<a class="code" href="class_a.html">a</a> * B.<a class="code" href="class_a.html">a</a>);
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator* (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, float B)
{
        return RGBAColor(A.r * B, A.g * B, A.b * B, A.<a class="code" href="class_a.html">a</a> * B);
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator* (float A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B)
{
        return B * A;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator/ (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B)
{
        return RGBAColor(A.r / B.r, A.g / B.g, A.b / B.b, A.<a class="code" href="class_a.html">a</a> / B.<a class="code" href="class_a.html">a</a>);
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator/ (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, float B)
{
        return RGBAColor(A.r / B, A.g / B, A.b / B, A.<a class="code" href="class_a.html">a</a> / B);
}

inline int operator&lt; (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B)
{
        return A.r &lt; B.r &amp;&amp; A.g &lt; B.g &amp;&amp; A.b &lt; B.b &amp;&amp; A.a &lt; B.a;
}

inline int operator== (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B)
{
        return (A.r == B.r) &amp;&amp; (A.g == B.g) &amp;&amp; (A.b == B.b) &amp;&amp; (A.a == B.a);
}

inline int operator!= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B)
{
        return !(A == B);
}


#endif




                // create a material and assign values 
        gbool <a class="code" href="g3render.h.html#a57">CreateMaterial</a>(LPDIRECT3D lpD3D,
                        LPDIRECT3DDEVICE lpDev, 
                        // material parameters
                        float ambient[3],float diffuse[3],float specular[3],float emissive[3],float alpha,float power,
                        // D3D specific
                        DWORD rampSize /* = 16 */, 
                        D3DTEXTUREHANDLE hTex,  /* Handle for the texture on the material.*/
                        /* out / in  must be released at end */
                        LPDIRECT3DMATERIAL &amp;lpmat,   /* Material object */
                        /* out */
                        D3DMATERIALHANDLE &amp;hMat /* Handle for the material  */
                        );

                // create a material and assign values with a single color 
        gbool <a class="code" href="g3render.h.html#a58">CreateSolidMaterial</a>(LPDIRECT3D lpD3D,
                        LPDIRECT3DDEVICE lpDev, 
                        // material parameters
                        //float diffuse[3],
            const <a class="code" href="class_rgbacolor.html">RGBAColor</a> &amp;color,
                        // texture handle
                        D3DTEXTUREHANDLE hTex,
                        /* out / in  must be released at end */
                        LPDIRECT3DMATERIAL &amp;lpmat,   /* Material object */
                        /* out */
                        D3DMATERIALHANDLE &amp;hMat /* Handle for the material  */
                        );





//
// G3Material
//

   

//@class GL-Style Material
class <a class="code" href="class_g3material.html">G3Material</a> : public  <a class="code" href="class_d3dmaterial.html">D3DMATERIAL</a> 
{
public:

/*
        RGBAColor ambient;
        RGBAColor diffuse;
        RGBAColor specular;
        RGBAColor emission;

        float shininess;
        float alpha;
*/
        gbool doSpecular; // flag if specular is not black 

    
        <a class="code" href="class_g3material.html#a0">G3Material</a>() { dwSize = sizeof(<a class="code" href="class_d3dmaterial.html">D3DMATERIAL</a>); hTexture = NULL; dwRampSize = 16; }

    <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; <a class="code" href="class_g3material.html#a1">Ambient</a>() { return *((<a class="code" href="class_rgbacolor.html">RGBAColor</a>*) &amp;ambient); }
    <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; <a class="code" href="class_g3material.html#a2">Diffuse</a>() { return *((<a class="code" href="class_rgbacolor.html">RGBAColor</a>*) &amp;diffuse); }
    <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; <a class="code" href="class_g3material.html#a3">Specular</a>() { return *((<a class="code" href="class_rgbacolor.html">RGBAColor</a>*) &amp;specular); }
    <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; <a class="code" href="class_g3material.html#a4">Emissive</a>() { return *((<a class="code" href="class_rgbacolor.html">RGBAColor</a>*) &amp;emissive); }
    <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; <a class="code" href="class_g3material.html#a5">Emission</a>() { return *((<a class="code" href="class_rgbacolor.html">RGBAColor</a>*) &amp;emissive); }

    <a class="code" href="class_g3material.html">G3Material</a> &amp; <a class="code" href="class_g3material.html#a6">Get</a>(<a class="code" href="class_point.html">Point</a> &amp;Ambient, <a class="code" href="class_point.html">Point</a> &amp;Diffuse, <a class="code" href="class_point.html">Point</a> &amp;Specular,<a class="code" href="class_point.html">Point</a> &amp;Emissive,float &amp;Shininess,float &amp;Alpha) 
    {
                 Ambient.<a class="code" href="class_point.html#a6">Set</a>(ambient);
                 Diffuse.<a class="code" href="class_point.html#a6">Set</a>(diffuse);
                 Specular.<a class="code" href="class_point.html#a6">Set</a>(specular);
                 Emissive.<a class="code" href="class_point.html#a6">Set</a>(emissive);
                 Shininess = power;
                 Alpha = diffuse.a;
                 return(*this);
        };


    // set material component wise as "Points"
        <a class="code" href="class_g3material.html">G3Material</a> &amp; <a class="code" href="class_g3exbuf.html#a8">Set</a>(const <a class="code" href="class_point.html">Point</a> &amp;Ambient, const <a class="code" href="class_point.html">Point</a> &amp;Diffuse,
                                     const <a class="code" href="class_point.html">Point</a> &amp;Specular,const <a class="code" href="class_point.html">Point</a> &amp;Emissive,
                                     float Shininess,float Alpha) {
                 Ambient.Get(ambient,Alpha);
                 Diffuse.Get(diffuse,Alpha);
                 Specular.Get(specular,Alpha);
                 Emissive.Get(emissive,Alpha);
                 power  = Shininess;
                 doSpecular = (specular.r&gt;0) || (specular.g&gt;0) || (specular.b&gt;0);
                 return(*this);
                };

        <a class="code" href="class_g3material.html">G3Material</a> &amp;<a class="code" href="class_g3exbuf.html#a8">Set</a>(
                        // material parameters
                        const float ambient[3],const float diffuse[3],const float specular[3],const float emissive[3],
                        float alpha,float power) 
        {

    this-&gt;diffuse.r = (D3DVALUE)diffuse[0];
    this-&gt;diffuse.g = (D3DVALUE)diffuse[1];
    this-&gt;diffuse.b = (D3DVALUE)diffuse[2];
    this-&gt;diffuse.<a class="code" href="class_a.html">a</a> = (D3DVALUE)alpha;
    this-&gt;ambient.r = (D3DVALUE)ambient[0];
    this-&gt;ambient.g = (D3DVALUE)ambient[1];
    this-&gt;ambient.b = (D3DVALUE)ambient[2];
    this-&gt;ambient.<a class="code" href="class_a.html">a</a> = (D3DVALUE)alpha;
    this-&gt;specular.r = (D3DVALUE)specular[0];
    this-&gt;specular.g = (D3DVALUE)specular[1];
    this-&gt;specular.b = (D3DVALUE)specular[2];
    this-&gt;specular.<a class="code" href="class_a.html">a</a> = (D3DVALUE)alpha;
    this-&gt;emissive.r = (D3DVALUE)emissive[0];
    this-&gt;emissive.g = (D3DVALUE)emissive[1];
    this-&gt;emissive.b = (D3DVALUE)emissive[2];
    this-&gt;emissive.<a class="code" href="class_a.html">a</a> = (D3DVALUE)alpha;
    this-&gt;power = power;
        doSpecular = (this-&gt;specular.r&gt;0) || (this-&gt;specular.g&gt;0) || (this-&gt;specular.b&gt;0);
        return(*this);
        }


        <a class="code" href="class_g3material.html">G3Material</a> &amp;<a class="code" href="class_g3exbuf.html#a8">Set</a> ( // material parameters
                                const <a class="code" href="class_d3dmaterial.html">D3DMATERIAL</a> &amp;mat
                                )

        {
                this-&gt;diffuse = mat.diffuse;
                this-&gt;ambient = mat.ambient;
                this-&gt;specular = mat.specular;
                this-&gt;emissive = mat.emissive;
                this-&gt;power = power;
                doSpecular = (this-&gt;specular.r&gt;0) || (this-&gt;specular.g&gt;0) || (this-&gt;specular.b&gt;0);
                // hTexture / hSpecular

                return(*this);

        }
        <a class="code" href="class_g3material.html">G3Material</a> &amp;<a class="code" href="class_g3exbuf.html#a8">Set</a> ( // material parameters
                        const <a class="code" href="class_rgbacolor.html">RGBAColor</a> &amp;color
                                )

        {
                this-&gt;diffuse = color;

                this-&gt;ambient.r = 0.0;
                this-&gt;ambient.g = 0.0;
                this-&gt;ambient.b = 0.0;
                this-&gt;ambient.<a class="code" href="class_a.html">a</a> = 0.0;
                this-&gt;specular.r = 0.0;
                this-&gt;specular.g = 0.0;
                this-&gt;specular.b = 0.0;
                this-&gt;specular.<a class="code" href="class_a.html">a</a> = 0.0;
                this-&gt;emissive = color;
                this-&gt;power = 0;
                doSpecular = gfalse;

                return(*this);

        }


    // set to a default 
        <a class="code" href="class_g3material.html">G3Material</a> &amp; <a class="code" href="class_g3material.html#a11">Default</a>() {
                ambient.r=ambient.g=ambient.b =0.2f;ambient.a = 1.0f;
                diffuse.r=diffuse.g=diffuse.b =0.8f;diffuse.a = 1.0f;
                specular.r=specular.g=specular.b =0.6f;specular.a = 1.0f;
                emissive.r=emissive.g=emissive.b =0.0f;emissive.a = 1.0f;
                power = 3.0;
                doSpecular = gtrue;
                return(*this);
   }

   // set alpha value 
   <a class="code" href="class_g3material.html">G3Material</a> &amp; <a class="code" href="class_g3material.html#a12">SetAlpha</a>(float <a class="code" href="class_a.html">a</a>) {
                ambient.a = <a class="code" href="class_a.html">a</a>;
                diffuse.a = <a class="code" href="class_a.html">a</a>;
                specular.a = <a class="code" href="class_a.html">a</a>;
                emissive.a = <a class="code" href="class_a.html">a</a>;
                return(*this);
   }

   float <a class="code" href="class_g3material.html#a13">GetAlpha</a>(float <a class="code" href="class_a.html">a</a>) {
                return (diffuse.a);
   }

   int <a class="code" href="class_point.html#a38">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);

   // Read Material
   int <a class="code" href="class_g3material.html#a15">ReadFromInventorFile</a>(const char *FileName);

};


//
// @class maintains a handle to a D3D Material
//
class <a class="code" href="class_g3materialhandle.html">G3MaterialHandle</a> 
{
public: 


        <a class="code" href="class_g3material.html">G3Material</a> material; // new for custom lighting 
        // custom lighting stuff
        // set material properties
        gbool <a class="code" href="class_g3exbuf.html#a8">Set</a>(float ambient[3],float diffuse[3],float specular[3],float emissive[3],float alpha,float power)
        {
                material.<a class="code" href="class_g3material.html#a7">Set</a>(ambient,diffuse,specular,emissive,alpha,power);
                defined = TRUE;
                return gtrue;
        }
        gbool <a class="code" href="class_g3materialhandle.html#a1">SetSolid</a>(const <a class="code" href="class_rgbacolor.html">RGBAColor</a> &amp;color)
        {
                material.<a class="code" href="class_g3material.html#a7">Set</a>(color);
                defined = TRUE;
                return gtrue;
        }


    int refCnt; // how many scene nodes are using this material 
    <a class="code" href="class_g3materialhandle.html">G3MaterialHandle</a> *next;    // Double link to from list of all materials in use
    <a class="code" href="class_g3materialhandle.html">G3MaterialHandle</a> *prev;



        <a class="code" href="class_g3materialhandle.html#a2">G3MaterialHandle</a>(): lpMat(NULL),hMat(0),hTexture(0),whiteDiffuse(FALSE), defined(FALSE) { refCnt = 0; next = prev = NULL; }
        <a class="code" href="class_g3materialhandle.html#a3">~G3MaterialHandle</a>() { if (lpMat) lpMat-&gt;Release(); }
    
    // release (free) material object
    void <a class="code" href="class_g3exbuf.html#a10">Release</a>() { if (lpMat) lpMat-&gt;Release(); lpMat = NULL; hMat = 0; hTexture = 0; defined = 0; }

    LPDIRECT3DMATERIAL lpMat;   /* Material object */
        D3DMATERIALHANDLE hMat;         /* Handle for the material  */

    D3DTEXTUREHANDLE  hTexture;   // handle for texture, only for ramp

        gbool   whiteDiffuse;   // is the diffuse color white ? 
        gbool   defined;                // was the material defined ??

    // Is definition valid ???
    gbool <a class="code" href="class_g3exbuf.html#a3">Ok</a>() { return (hMat != 0); }
    void <a class="code" href="class_g3materialhandle.html#a6">Ref</a>() { refCnt++; }
    void <a class="code" href="class_g3materialhandle.html#a7">UnRef</a>() { refCnt--;  if (refCnt == 0) <a class="code" href="class_g3exbuf.html#a10">Release</a>(); }

        
        operator D3DMATERIALHANDLE() const { return hMat; }
        D3DTEXTUREHANDLE <a class="code" href="class_g3materialhandle.html#a9">GetTextureHandle</a>() const { return hTexture;}


        // set material properties
        gbool <a class="code" href="class_g3exbuf.html#a8">Set</a>(LPDIRECT3D lpD3D,
                        LPDIRECT3DDEVICE lpDev, 
                        // material parameters
                        float ambient[3],float diffuse[3],float specular[3],float emissive[3],float alpha,float power,
                        // D3D specific
                        DWORD rampSize /* = 16 */, 
                        D3DTEXTUREHANDLE hTex  /* Handle for the texture on the material.*/
                        ) { 
                hTexture = hTex;
                return 
                                CreateMaterial(lpD3D,lpDev,
                                        ambient,diffuse,specular,emissive,alpha,power,
                                        rampSize,hTex,
                                        lpMat,hMat); 
                        }
        

        // set material properties
        gbool <a class="code" href="class_g3exbuf.html#a8">Set</a>(LPDIRECT3D lpD3D,
                         LPDIRECT3DDEVICE lpDev, 
                         // material parameters
             <a class="code" href="class_d3dmaterial.html">D3DMATERIAL</a> &amp;mat) 
          {
                        <a class="code" href="g3render.h.html#a0">D3DLASTERROR</a>()

            if (!lpMat) 
                     if ( <a class="code" href="g3render.h.html#a2">D3DCheck</a>(lpD3D-&gt;CreateMaterial(&amp;lpMat, NULL)) != D3D_OK)
                 return FALSE;

                         hTexture = mat.hTexture;

             <a class="code" href="g3render.h.html#a2">D3DCheck</a>(lpMat-&gt;SetMaterial(&amp;mat));
             <a class="code" href="g3render.h.html#a2">D3DCheck</a>(lpMat-&gt;GetHandle(lpDev, &amp;hMat));
                 return TRUE;

          }    
        


        // set material to solid single color
        gbool <a class="code" href="class_g3materialhandle.html#a1">SetSolid</a>(LPDIRECT3D lpD3D,
                        LPDIRECT3DDEVICE lpDev, 
                        // material parameters
                        //float diffuse[3]
            const <a class="code" href="class_rgbacolor.html">RGBAColor</a> &amp;color,
                        D3DTEXTUREHANDLE hTex = 0
                        ) { 
                hTexture = hTex;

                                return  <a class="code" href="g3render.h.html#a58">CreateSolidMaterial</a>(lpD3D,lpDev, color, hTex, lpMat,hMat); 
                        }

    // apply current material handle as background for viewport
        void <a class="code" href="class_g3materialhandle.html#a13">SetBackground</a>(LPDIRECT3DVIEWPORT lpView) 
        { 
                <a class="code" href="g3render.h.html#a0">D3DLASTERROR</a>()
                <a class="code" href="g3render.h.html#a2">D3DCheck</a>(lpView-&gt;SetBackground(hMat)); 
        }

        // add to execute buffer
        void <a class="code" href="class_g3materialhandle.html#a14">put</a>(LPVOID &amp;lpPointer) const {
                <a class="code" href="d3dmacs.h.html#a6">OP_STATE_LIGHT</a>(1, lpPointer);
                        <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(D3DLIGHTSTATE_MATERIAL, hMat, lpPointer);
        }

        // return instruction size
        DWORD <a class="code" href="class_g3exbufptr.html#a30">size</a>() const { return sizeof(D3DINSTRUCTION) * 1 + sizeof(D3DSTATE) * 1; }
};




//
// G3MaterialRef
//
// holds a pointer to a G3MaterialHandle

class <a class="code" href="class_g3materialref.html">G3MaterialRef</a>
{

/* protected: */
public: 

    <a class="code" href="class_g3materialhandle.html">G3MaterialHandle</a> *handle;

public:

    <a class="code" href="class_g3materialref.html#a0">G3MaterialRef</a>() : handle(NULL) { };
    // is material handle valide or need to redefine ?

    gbool <a class="code" href="class_g3exbuf.html#a3">Ok</a>() { return (handle &amp;&amp; handle-&gt;<a class="code" href="class_g3materialhandle.html#a5">Ok</a>()); }
    
    void <a class="code" href="class_g3exbuf.html#a10">Release</a>() {
        if (handle) handle-&gt;<a class="code" href="class_g3materialhandle.html#a7">UnRef</a>();
        handle = NULL;
    }

    // Notify handle (owned by renderstate) that this ref doesn´t need the handle any more
    <a class="code" href="class_g3materialref.html#a3">~G3MaterialRef</a>() {
        if (handle) handle-&gt;<a class="code" href="class_g3materialhandle.html#a7">UnRef</a>();
        handle = NULL;
    }

    friend class <a class="code" href="class_renderstate.html">RenderState</a>;
};

//
// G3TextureHandle
// @class maintains a handle to a D3D Texture
//
class <a class="code" href="class_g3texturehandle.html">G3TextureHandle</a> : public <a class="code" href="class_gtexturehandle.html">GTextureHandle</a> 
{
public: 

    D3DTEXTUREHANDLE        hTexture;            /* handle */
    LPDIRECTDRAWSURFACE     lpTextureSurf;       /* surface */
    LPDIRECT3DTEXTURE       lpTexture;           /* texture obj */


        <a class="code" href="class_g3texturehandle.html">G3TextureHandle</a> *<a class="code" href="class_gtexturehandle.html#a2">Next</a>() { return (<a class="code" href="class_g3texturehandle.html">G3TextureHandle</a> *) next; }

        <a class="code" href="class_g3texturehandle.html#a1">G3TextureHandle</a>(): lpTexture(NULL),lpTextureSurf(NULL),hTexture(0) {  
        }

        <a class="code" href="class_g3texturehandle.html#a2">~G3TextureHandle</a>() { <a class="code" href="class_g3exbuf.html#a10">Release</a>(); }
    
    // release (free)  object
    virtual void <a class="code" href="class_g3exbuf.html#a10">Release</a>() { 
                <a class="code" href="g3render.h.html#a0">D3DLASTERROR</a>()
                if (lpTexture) { 
                        /*D3DCheck(*/ 
                                lpTexture-&gt;Unload(); // error here
                        //D3DCheck(
                                lpTexture-&gt;Release(); 
                        lpTexture = NULL; 
                }
                if (lpTextureSurf) 
                        <a class="code" href="g3render.h.html#a2">D3DCheck</a>(lpTextureSurf-&gt;Release()); 
                lpTextureSurf = NULL; 
                hTexture = 0; 
                inVideoMem = TRUE;
        }

        // is the surface lost 
        gbool <a class="code" href="class_gtexturehandle.html#a4">CheckSurfaceLost</a>() 
        {
                HRESULT GLastError;
                if (lpTextureSurf &amp;&amp; lpTextureSurf-&gt;IsLost() == DDERR_SURFACELOST) { 
             GLastError = lpTextureSurf-&gt;Restore(); 
             if (GLastError != DD_OK) return(FALSE);
                         //ReloadTextureSurf();
             return(TRUE);

                }
        else return(FALSE);
        }
        
        inline gbool <a class="code" href="class_gtexturehandle.html#a5">CheckInVideoMem</a>()  { return inVideoMem; }

        
        // load surface from fileName
        gbool <a class="code" href="class_g3texturehandle.html#a6">LoadTextureSurf</a>(<a class="code" href="class_gd3device.html">GD3Device</a> *device,<a class="code" href="class_renderstate.html">RenderState</a> &amp;state);  // in G3Texture
        gbool <a class="code" href="class_g3texturehandle.html#a6">LoadTextureSurf</a>(<a class="code" href="class_gd3device.html">GD3Device</a> *device,<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,<a class="code" href="class_image_.html">image</a> &amp;im);
        gbool <a class="code" href="class_g3texturehandle.html#a6">LoadTextureSurf</a>(<a class="code" href="class_gd3device.html">GD3Device</a> *device,<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,
                LPDIRECTDRAWSURFACE srcSurface,IDirectDrawPalette *srcPalette,
                DDSURFACEDESC &amp;srcDdsd, RECT &amp;srcRect,RECT *targetSizeRect=NULL);
        

        gbool <a class="code" href="class_g3texturehandle.html#a9">ReloadTextureSurf</a>(<a class="code" href="class_gd3device.html">GD3Device</a> *device,<a class="code" href="class_renderstate.html">RenderState</a> &amp;state);
        gbool <a class="code" href="class_g3texturehandle.html#a10">UnloadTextureSurf</a>(<a class="code" href="class_gd3device.html">GD3Device</a> *device,<a class="code" href="class_renderstate.html">RenderState</a> &amp;state);


        // get the current texuture handle of the texture object 
    void <a class="code" href="class_g3texturehandle.html#a11">GetHandle</a>(LPDIRECT3DDEVICE lpDev) {
                <a class="code" href="g3render.h.html#a0">D3DLASTERROR</a>()
        <a class="code" href="g3render.h.html#a2">D3DCheck</a>(lpTexture-&gt;GetHandle(lpDev, &amp;hTexture));
    }

    // Is definition valid ???
    inline gbool <a class="code" href="class_g3exbuf.html#a3">Ok</a>() { return !inVideoMem || (lpTextureSurf != NULL &amp;&amp; hTexture != 0); }

    void <a class="code" href="class_gtexturehandle.html#a14">Ref</a>() { refCnt++; }

    void <a class="code" href="class_gtexturehandle.html#a15">UnRef</a>() { refCnt--;  if (refCnt == 0) <a class="code" href="class_g3exbuf.html#a10">Release</a>(); }

        inline operator D3DTEXTUREHANDLE() const { return hTexture; }

        inline D3DTEXTUREHANDLE <a class="code" href="class_g3texturehandle.html#a16">GetTextureHandle</a>() const { return hTexture;}


        // set texture by texture filename 
        gbool <a class="code" href="class_g3exbuf.html#a8">Set</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state, LPCTSTR fileName,int format=0, LPCTSTR fileUrl=NULL);

        // set texture from image data
        gbool <a class="code" href="class_g3exbuf.html#a8">Set</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state, int format,int width,int height,int numComponents,unsigned char *data, char *colorTable=NULL);

        // set texture surface from image data
        // gbool SetTexture(RenderState &amp;state,
        //              int format,int width,int height,
        //              unsigned char *data, char *colorTable=NULL);

        // set by image 
        gbool <a class="code" href="class_g3exbuf.html#a8">Set</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,<a class="code" href="class_image_.html">image</a> *im,gbool checkScale=TRUE,gbool checkFormat=TRUE,gbool filteredScale=TRUE);
        gbool <a class="code" href="class_g3exbuf.html#a8">Set</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,LPDIRECTDRAWSURFACE srcSurface,IDirectDrawPalette *srcPalette,DDSURFACEDESC &amp;srcDdsd, RECT &amp;srcRect,gbool checkScale=TRUE,gbool checkFormat=TRUE,gbool filteredScale=TRUE);


    // set texture handle 
    static void <a class="code" href="class_g3texturehandle.html#d0">put</a>(D3DTEXTUREHANDLE hTex,LPVOID &amp;lpPointer) {
                <a class="code" href="d3dmacs.h.html#a8">OP_STATE_RENDER</a>(1, lpPointer);
            <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(D3DRENDERSTATE_TEXTUREHANDLE, hTex, lpPointer);
        }

    // set texture handle 
    void <a class="code" href="class_g3texturehandle.html#d0">put</a>(LPVOID &amp;lpPointer) {
                rendered = TRUE;        
                <a class="code" href="d3dmacs.h.html#a8">OP_STATE_RENDER</a>(1, lpPointer);
            <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(D3DRENDERSTATE_TEXTUREHANDLE, hTexture, lpPointer);
        }

        // helper for optimizer 
        // return image 
        gbool <a class="code" href="class_g3texturehandle.html#a22">GetImage</a>(<a class="code" href="class_image_.html">image</a> &amp;im);

};


//
// G3TextureHandle
// @class maintains a handle to a D3D Texture // Direct X 6 Version 
//
class <a class="code" href="class_g3texturehandle2.html">G3TextureHandle2</a> : public <a class="code" href="class_gtexturehandle.html">GTextureHandle</a> 
{
public: 

    LPDIRECTDRAWSURFACE     lpTextureSurf;       /* surface */
    LPDIRECT3DTEXTURE2      lpTexture;           /* texture obj */

        <a class="code" href="class_g3texturehandle2.html">G3TextureHandle2</a> *<a class="code" href="class_gtexturehandle.html#a2">Next</a>() { return (<a class="code" href="class_g3texturehandle2.html">G3TextureHandle2</a> *) next; }

        <a class="code" href="class_g3texturehandle2.html#a1">G3TextureHandle2</a>(): lpTexture(NULL),lpTextureSurf(NULL) {  
        }

        <a class="code" href="class_g3texturehandle2.html#a2">~G3TextureHandle2</a>() { <a class="code" href="class_g3exbuf.html#a10">Release</a>(); }
    
    // release (free)  object
    virtual void <a class="code" href="class_g3exbuf.html#a10">Release</a>() { 
                <a class="code" href="g3render.h.html#a0">D3DLASTERROR</a>()
                if (lpTexture) { 
                        /*D3DCheck(*/ 
                        //      lpTexture-&gt;Unload(); // error here
                        //D3DCheck(
                        lpTexture-&gt;Release(); 
                        lpTexture = NULL; 
                }
                if (lpTextureSurf) 
                        <a class="code" href="g3render.h.html#a2">D3DCheck</a>(lpTextureSurf-&gt;Release()); 
                lpTextureSurf = NULL; 
                inVideoMem = TRUE;
        }

        // is the surface lost 
        gbool <a class="code" href="class_gtexturehandle.html#a4">CheckSurfaceLost</a>() 
        {
                HRESULT GLastError;
                if (lpTextureSurf &amp;&amp; lpTextureSurf-&gt;IsLost() == DDERR_SURFACELOST) { 
             GLastError = lpTextureSurf-&gt;Restore(); 
             if (GLastError != DD_OK) return(FALSE);
                         //ReloadTextureSurf();
             return(TRUE);

                }
        else return(FALSE);
        }
        
        inline gbool <a class="code" href="class_gtexturehandle.html#a5">CheckInVideoMem</a>()  { return inVideoMem; }

        
        // load surface from fileName
        gbool <a class="code" href="class_g3texturehandle2.html#a6">LoadTextureSurf</a>(<a class="code" href="class_gd3device.html">GD3Device</a> *device,<a class="code" href="class_renderstate.html">RenderState</a> &amp;state);  // in G3Texture
        gbool <a class="code" href="class_g3texturehandle2.html#a6">LoadTextureSurf</a>(<a class="code" href="class_gd3device.html">GD3Device</a> *device,<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,<a class="code" href="class_image_.html">image</a> &amp;im);
        gbool <a class="code" href="class_g3texturehandle2.html#a6">LoadTextureSurf</a>(<a class="code" href="class_gd3device.html">GD3Device</a> *device,<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,
                LPDIRECTDRAWSURFACE srcSurface,IDirectDrawPalette *srcPalette,
                DDSURFACEDESC &amp;srcDdsd, RECT &amp;srcRect,RECT *targetSizeRect=NULL);
        

        gbool <a class="code" href="class_g3texturehandle2.html#a9">ReloadTextureSurf</a>(<a class="code" href="class_gd3device.html">GD3Device</a> *device,<a class="code" href="class_renderstate.html">RenderState</a> &amp;state);
        gbool <a class="code" href="class_g3texturehandle2.html#a10">UnloadTextureSurf</a>(<a class="code" href="class_gd3device.html">GD3Device</a> *device,<a class="code" href="class_renderstate.html">RenderState</a> &amp;state);


        // get the current texuture handle of the texture object 
    void <a class="code" href="class_g3texturehandle2.html#a11">GetHandle</a>(LPDIRECT3DDEVICE lpDev) {
    }

    // Is definition valid ???
    inline gbool <a class="code" href="class_g3exbuf.html#a3">Ok</a>() { return !inVideoMem || (lpTextureSurf != NULL); }

    void <a class="code" href="class_gtexturehandle.html#a14">Ref</a>() { refCnt++; }

    void <a class="code" href="class_gtexturehandle.html#a15">UnRef</a>() { refCnt--;  if (refCnt == 0) <a class="code" href="class_g3exbuf.html#a10">Release</a>(); }

        //inline operator D3DTEXTUREHANDLE() const { return hTexture; }

        //inline D3DTEXTUREHANDLE GetTextureHandle() const { return hTexture;}


        // set texture by texture filename 
        gbool <a class="code" href="class_g3exbuf.html#a8">Set</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state, LPCTSTR fileName,int format=0, LPCTSTR fileUrl=NULL);

        // set texture from image data
        gbool <a class="code" href="class_g3exbuf.html#a8">Set</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state, int format,int width,int height,int numComponents,unsigned char *data, char *colorTable=NULL);

        // set texture surface from image data
        // gbool SetTexture(RenderState &amp;state,
        //              int format,int width,int height,
        //              unsigned char *data, char *colorTable=NULL);

        // set by image 
        gbool <a class="code" href="class_g3exbuf.html#a8">Set</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,<a class="code" href="class_image_.html">image</a> *im,gbool checkScale=TRUE,gbool checkFormat=TRUE,gbool filteredScale=TRUE);
        gbool <a class="code" href="class_g3exbuf.html#a8">Set</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,LPDIRECTDRAWSURFACE srcSurface,IDirectDrawPalette *srcPalette,DDSURFACEDESC &amp;srcDdsd, RECT &amp;srcRect,gbool checkScale=TRUE,gbool checkFormat=TRUE,gbool filteredScale=TRUE);


        // helper for optimizer 
        // return image 
        gbool <a class="code" href="class_g3texturehandle2.html#a19">GetImage</a>(<a class="code" href="class_image_.html">image</a> &amp;im);

};






// D3D has a limitation of number of verts per buffer
// so for large objects we need to have a set of buffer
class <a class="code" href="class_g3objref.html">G3ObjRef</a>
{
protected:

public:

    <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_g3exbufhandle.html">G3ExBufHandle</a> *&gt; exBuf;       // array of execute buffers
    <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_g3materialhandle.html">G3MaterialHandle</a> *&gt; mat;      // array of local materials 
        unsigned long textureMatrixVersion;             // id of current textureMatrix applied, 0 identity
        gbool unlit;            // is this an unlit geometry 

public:

    <a class="code" href="class_g3objref.html#a0">G3ObjRef</a>() { textureMatrixVersion = 0; unlit = FALSE; };
    
        // is ExBuf handle valid or need to redefine ?
    gbool <a class="code" href="class_g3exbuf.html#a3">Ok</a>() const { return (exBuf.<a class="code" href="class_array.html#a21">Length</a>()&gt;0 &amp;&amp; exBuf[0]-&gt;Ok()); }

        // is Material handle valid or need to redefine ?
    gbool <a class="code" href="class_g3objref.html#a2">MatOk</a>() const { return (mat.<a class="code" href="class_array.html#a21">Length</a>()&gt;0 &amp;&amp; mat[0]-&gt;Ok()); }

        // is this a multibuffer object ? 
    gbool <a class="code" href="class_g3objref.html#a3">IsMulti</a>() const { return (exBuf.<a class="code" href="class_array.html#a21">Length</a>()&gt;1); }

        // append one more material
        void <a class="code" href="class_g3objref.html#a4">Append</a>(<a class="code" href="class_g3materialhandle.html">G3MaterialHandle</a> * newMat) { mat.<a class="code" href="class_array.html#a38">Append</a>(newMat); }

        // append one more buffer 
        void <a class="code" href="class_g3objref.html#a4">Append</a>(<a class="code" href="class_g3exbufhandle.html">G3ExBufHandle</a> * newBuf) { exBuf.<a class="code" href="class_array.html#a38">Append</a>(newBuf); }

    // release buffers after i 
    void <a class="code" href="class_g3objref.html#a6">Truncate</a>(int newLength) {
                for (int i=newLength; i&lt; exBuf.<a class="code" href="class_array.html#a21">Length</a>(); i++) exBuf[i]-&gt;UnRef();
                exBuf.<a class="code" href="class_array.html#a33">SetLength</a>(newLength);
    }


    // release buffers &amp; materials 
    void <a class="code" href="class_g3exbuf.html#a10">Release</a>() {
                for (int i=0; i&lt; exBuf.<a class="code" href="class_array.html#a21">Length</a>(); i++) exBuf[i]-&gt;UnRef();
                exBuf.<a class="code" href="class_array.html#a33">SetLength</a>(0);
                for (int j=0; j&lt; mat.<a class="code" href="class_array.html#a21">Length</a>(); j++) mat[j]-&gt;UnRef();
                mat.<a class="code" href="class_array.html#a33">SetLength</a>(0);
    }

    // execute the buffer(s) 
        gbool <a class="code" href="class_g3exbuf.html#a9">Execute</a>(LPDIRECT3DDEVICE lpDev, LPDIRECT3DVIEWPORT lpView, DWORD mode = D3DEXECUTE_UNCLIPPED)
        { 
                for (int i=0; i&lt; exBuf.<a class="code" href="class_array.html#a21">Length</a>(); i++) {
                    if (!exBuf[i]-&gt;Execute(lpDev,lpView,mode)) return(FALSE); 
                }
                return(TRUE);
        }

    // Notify handle (owned by renderstate) that this ref doesn´t need the handle any more
    <a class="code" href="class_g3objref.html#a9">~G3ObjRef</a>() {
                <a class="code" href="class_g3exbuf.html#a10">Release</a>();
    }

    friend class <a class="code" href="class_renderstate.html">RenderState</a>;
};







//
// @class light information
//
typedef enum 
        {
        GL_AMBIENT=1,  // do ambient
        GL_SPECULAR=2,  // do specular, comming from material
        GL_RANGE=4,             // do range compuation
        GL_DIFFUSE=8,   // do diffuse
        GL_ATTENUATION=16,      // do atten
        GL_FOG=32,              // do diffuse
        }
        GLIGHT_FLAGS;


class <a class="code" href="class_g3lighthandle.html">G3LightHandle</a> : public <a class="code" href="class_d3dlight.html">D3DLIGHT</a> {
public:

        <a class="code" href="class_rgbacolor.html">RGBAColor</a>        ambientColor;                  /* light color * ambient intensity */

    <a class="code" href="class_point.html">Point</a>                positionLocal;                 /* Position in local space */
        <a class="code" href="class_point.html">Point</a>            directionLocal;                /* Direction in local space */
        float            rangeLocal;                    // range 

    <a class="code" href="class_point.html">Point</a>                positionView;                  // Position in view coordinates
        <a class="code" href="class_point.html">Point</a>            directionView;                 // Direction in view coordinates
        float            rangeView;                             // range 

        float            cosTheta,cosPhi;               // angles in radians

        int                      flags;                                 // light flags 

    int refCnt;                         // how many scene nodes are using this material 
    <a class="code" href="class_g3lighthandle.html">G3LightHandle</a> *next;    // Double link to form list of all lights in use
    <a class="code" href="class_g3lighthandle.html">G3LightHandle</a> *prev;

        // for custom lighting
        float            ambientIntensity;

        <a class="code" href="class_rgbacolor.html">RGBAColor</a>        kAmbient,kDiffuse,kSpecular; // cached multiplies // material * light  

    
        // is this light enabled, ie added to the viewport ?
        gbool enabled;

        /* D3D light object  */
        LPDIRECT3DLIGHT lpD3DLight; 

        /* we keep a pointer to the viewpoint */
        LPDIRECT3DVIEWPORT lpView;

    void <a class="code" href="class_gtexturehandle.html#a14">Ref</a>() { refCnt++; }
    void <a class="code" href="class_gtexturehandle.html#a15">UnRef</a>() { refCnt--;  if (refCnt == 0) <a class="code" href="class_g3exbuf.html#a10">Release</a>(); }

        // is the light ok ?? 
    gbool <a class="code" href="class_g3exbuf.html#a3">Ok</a>() const { return(lpD3DLight != NULL &amp;&amp; enabled); } 

    // release (free) light object
        // we can't do the release directly here, because light has to be removed from viewport
    void <a class="code" href="class_g3exbuf.html#a10">Release</a>() { if (lpView) <a class="code" href="class_g3exbuf.html#a10">Release</a>(lpView); } 
    //void Release() { if (lpD3DLight) lpD3DLight-&gt;Release();  lpD3DLight = NULL; }

    // release (free) light  object and remove from view 
    void <a class="code" href="class_g3exbuf.html#a10">Release</a>(LPDIRECT3DVIEWPORT theView);
        
        // set the ligth to lpD3DLight 
        gbool <a class="code" href="class_g3exbuf.html#a8">Set</a>(LPDIRECT3D lpD3D)
        {
                if (lpD3DLight == NULL)         
                        if (lpD3D-&gt;CreateLight(&amp;lpD3DLight, NULL) != D3D_OK)
                                return FALSE;
                if (lpD3DLight-&gt;SetLight(this) != D3D_OK)
                        return FALSE;
                return(TRUE);
                
        }

        // add light to viewport
        gbool <a class="code" href="class_g3lighthandle.html#a6">Add</a>(LPDIRECT3DVIEWPORT theView) {
                if (theView-&gt;AddLight(lpD3DLight) != D3D_OK)
                        return FALSE;
                enabled = TRUE;
                lpView = theView;
                return TRUE;
        }

        // remove light from viewport 
        gbool <a class="code" href="class_g3lighthandle.html#a7">Delete</a>(LPDIRECT3DVIEWPORT theView) {
                enabled = FALSE;
                lpView = NULL;
                if (theView-&gt;DeleteLight(lpD3DLight) != D3D_OK)
                        return FALSE;
                return TRUE;
        }

        <a class="code" href="class_g3lighthandle.html#a8">G3LightHandle</a>();

        <a class="code" href="class_g3lighthandle.html#a9">~G3LightHandle</a>();
    
        void <a class="code" href="class_g3lighthandle.html#a10">SetDirection</a>(const <a class="code" href="class_point.html">Point</a> direction) { dvDirection = direction; }

        // set type of light 
        void <a class="code" href="class_g3lighthandle.html#a11">SetType</a>(D3DLIGHTTYPE type) { dltType=type; }
    
        gbool <a class="code" href="class_g3lighthandle.html#a12">IsDirectional</a>() const { return dltType == D3DLIGHT_DIRECTIONAL;}
    gbool <a class="code" href="class_g3lighthandle.html#a13">IsSpot</a>() const { return dltType == D3DLIGHT_SPOT;}
    gbool <a class="code" href="class_g3lighthandle.html#a14">IsPoint</a>() const { return dltType == D3DLIGHT_POINT;}
};

//
// G3LightRef
//
// holds a pointer to a G3Light

class <a class="code" href="class_g3lightref.html">G3LightRef</a>
{

//protected:
public:

    <a class="code" href="class_g3lighthandle.html">G3LightHandle</a> *handle;

public:

    <a class="code" href="class_g3lightref.html#a0">G3LightRef</a>() : handle(NULL) { };

    // is light handle valid or need to be redefined ?
    gbool <a class="code" href="class_g3exbuf.html#a3">Ok</a>() { return (handle &amp;&amp; handle-&gt;<a class="code" href="class_g3lighthandle.html#a2">Ok</a>()); }
    
    void <a class="code" href="class_g3exbuf.html#a10">Release</a>() {
        if (handle) handle-&gt;<a class="code" href="class_g3lighthandle.html#a1">UnRef</a>();
        handle = NULL;
    }

    // Notify handle (owned by renderstate) that this ref doesn´t need the handle any more
    <a class="code" href="class_g3lightref.html#a3">~G3LightRef</a>() {
        if (handle) handle-&gt;<a class="code" href="class_g3lighthandle.html#a1">UnRef</a>();
        handle = NULL;
    }

    friend class <a class="code" href="class_renderstate.html">RenderState</a>;
};



//
// G3Matrix
//
// maintains a handle to a D3D Matrix
/*
  bad DeleteMatrix need lpdev !!!!
  A/ store point to lpdev in matrix
  or build a state matrix handle table 
  Matrix 
        operator D3DMATRIX &amp;() {
                ASSERT(sizeof(D3DMATRIX) == sizeof(m));
                return * (( D3DMATRIX *) &amp;m[0][0]); }
                }
*/
class <a class="code" href="class_g3matrix.html">G3Matrix</a> {
public: 

        <a class="code" href="class_g3matrix.html#a0">G3Matrix</a>(): hMat(NULL) {}
        void <a class="code" href="class_g3exbuf.html#a10">Release</a>() { hMat = NULL; }
        <a class="code" href="class_g3matrix.html#a2">~G3Matrix</a>() { <a class="code" href="class_g3exbuf.html#a10">Release</a>(); }

        D3DMATRIXHANDLE hMat; // handle to matrix 


        operator D3DMATRIXHANDLE() const { return hMat; }

        gbool <a class="code" href="class_g3exbuf.html#a8">Set</a>(LPDIRECT3DDEVICE lpDev,D3DMATRIX &amp;data) 
        { 

                <a class="code" href="g3render.h.html#a0">D3DLASTERROR</a>()

                if (!hMat)
                if (<a class="code" href="g3render.h.html#a2">D3DCheck</a>(lpDev-&gt;CreateMatrix(&amp;hMat)) != D3D_OK) 
                        return FALSE; 
                if (<a class="code" href="g3render.h.html#a2">D3DCheck</a>(lpDev-&gt;SetMatrix(hMat, &amp;data)) != D3D_OK) 
                        return FALSE;

                return TRUE; 
        }

        gbool <a class="code" href="class_g3matrix.html#a5">Get</a>(LPDIRECT3DDEVICE lpDev,D3DMATRIX &amp;data) 
        { 
                <a class="code" href="g3render.h.html#a0">D3DLASTERROR</a>()

                if (<a class="code" href="g3render.h.html#a2">D3DCheck</a>(lpDev-&gt;GetMatrix(hMat, &amp;data)) != D3D_OK) 
                                return FALSE;
                return TRUE; 
        }

        gbool <a class="code" href="class_g3matrix.html#a6">Delete</a>(LPDIRECT3DDEVICE lpDev) 
        { 
                <a class="code" href="g3render.h.html#a0">D3DLASTERROR</a>()
                if (hMat !=0) {
                        if (<a class="code" href="g3render.h.html#a2">D3DCheck</a>(lpDev-&gt;DeleteMatrix(hMat)) != D3D_OK) 
                                return FALSE;
                        hMat = 0;
                }
                return TRUE; 
        }


        //  if already
        void <a class="code" href="class_g3matrix.html#a7">put</a>(LPVOID &amp;lpPointer,D3DTRANSFORMSTATETYPE what) const {
                 <a class="code" href="d3dmacs.h.html#a7">OP_STATE_TRANSFORM</a>(1, lpPointer);
                         <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(what, hMat, lpPointer);
        }

        DWORD <a class="code" href="class_g3exbufptr.html#a30">size</a>() const { return sizeof(D3DINSTRUCTION) * 1 + sizeof(D3DSTATE) * 1; }

        static D3DMATRIX identity;
};

// class Renderflags : contains rendering style flags
//
class <a class="code" href="class_renderflags.html">RenderFlags</a> {
public:
                int visible:1;          // item is visible
                int lighted:1;          // item is affected by lights (so pass normals to GL)
                int smooth:1;                   // item should be smooth (gouaud) shaded
                int textured:1;         // item should be textured, if parameters available
                int colored:1;          // item should use local colors, if available
                int useMaterialColor:1; // use Material color (instead of item color )

                <a class="code" href="class_renderflags.html#a0">RenderFlags</a>(int Visible=1,int Lighted=1,int Smooth=1,int Colored=0,int Textured=0,int UseMaterialColor=1) {
                   visible=Visible,lighted=Lighted,smooth=Smooth;
                   colored=Colored;
                   textured=Textured;
                   useMaterialColor=UseMaterialColor;
                }
};

extern const char * <a class="code" href="g3render.h.html#a59">GFilterLookup</a>(int v);
extern int <a class="code" href="g3render.h.html#a59">GFilterLookup</a>(const char *v);

//@class GL-Texture mapping options
// texture sub options from  D3DRENDERSTATETYPE
class <a class="code" href="class_g3textureparameters.html">G3TextureParameters</a> {
public :
        D3DTEXTUREFILTER min_filter;    // minification filter 
        D3DTEXTUREFILTER mag_filter;    // magnification filter 

    gbool wrap_s;
        gbool wrap_t;

    gbool set_diffuse_white;
        int max_size_x,max_size_y; // maximum allow texture size 
        int current_max_size_x,current_max_size_y; // current allowed texture size , idea scale down textures if few texture memory
        int min_size_x,min_size_y; //  min allowed minimum texture size , idea scale down textures if few texture memory
        gbool square_size;                      // true, only square texture size allowed
        gbool border;                           // can do border 

        //   BOOL perspective; part of RenderState
    D3DTEXTUREBLEND blend;                      // blending function

    D3DTEXTUREBLEND defaultBlend;       // default blend function
    D3DTEXTUREBLEND unlitBlend;         // blend function for unlit textures 

        gbool gen_mipmaps;
        int supported_image_fmts;               // supported image formts for texture images ( image.h)
        // border color

    static const <a class="code" href="class_is.html">IS</a> filters[]; // table of filter names 
    static const <a class="code" href="class_is.html">IS</a> blends[];  // table of texture blend names 

        void <a class="code" href="class_g3textureparameters.html#a0">SetMinFilter</a>(int filter) {
        if (filter&gt;=0) min_filter = (D3DTEXTUREFILTER) filter;
        };
        void <a class="code" href="class_g3textureparameters.html#a1">SetMagFilter</a>(int filter) {
        if (filter&gt;=0) mag_filter = (D3DTEXTUREFILTER) filter;
        };


        void <a class="code" href="class_g3textureparameters.html#a2">SetWrap</a>(gbool s,gbool t) {
              wrap_s = s ?  TRUE : FALSE;
              wrap_t = t ?  TRUE : FALSE;
        } ;

        void <a class="code" href="class_g3textureparameters.html#a3">GetWrap</a>(gbool &amp;s,gbool &amp;t) {
              s = wrap_s;
              t = wrap_t;
        };
        void <a class="code" href="class_g3textureparameters.html#a0">SetMinFilter</a>(const char *filter) {
        int v = Lookup(filters,filter);
        if (v&gt;=0) min_filter = (D3DTEXTUREFILTER) v;
        };

        void <a class="code" href="class_g3textureparameters.html#a1">SetMagFilter</a>(const char *filter) {
        int v = Lookup(filters,filter);
        if (v&gt;=0) mag_filter = (D3DTEXTUREFILTER) v;
        };

        const char * <a class="code" href="class_g3textureparameters.html#a6">GetMinFilter</a>() { return Lookup(filters,min_filter); }
        const char * <a class="code" href="class_g3textureparameters.html#a7">GetMagFilter</a>() { return Lookup(filters,mag_filter); }

        void <a class="code" href="class_g3textureparameters.html#a8">SetBlend</a>(const char *filter) {
        int v = Lookup(blends,filter);
        if (v&gt;=0) blend = defaultBlend = (D3DTEXTUREBLEND) v;
        };
        
        const char * <a class="code" href="class_g3textureparameters.html#a9">GetBlend</a>(){ return Lookup(blends,blend); }

        void <a class="code" href="class_g3textureparameters.html#a10">SetUnlitBlend</a>(const char *filter) {
        int v = Lookup(blends,filter);
        if (v&gt;=0) unlitBlend = (D3DTEXTUREBLEND) v;
        };

        const char * <a class="code" href="class_g3textureparameters.html#a11">GetUnlitBlend</a>(){ return Lookup(blends,unlitBlend); }

        int <a class="code" href="class_g3textureparameters.html#a12">GetMaxBlend</a>() { return D3DTBLEND_COPY; }

        <a class="code" href="class_g3textureparameters.html#a13">G3TextureParameters</a>();

        gbool <a class="code" href="class_g3textureparameters.html#a14">NeedMipmaps</a>() { return( (min_filter &gt;= D3DFILTER_MIPNEAREST) || (gen_mipmaps)); }

        int <a class="code" href="class_g3textureparameters.html#a15">SetMaxSize</a>(int size_x,int size_y);

        void <a class="code" href="class_g3textureparameters.html#a16">GetMaxSize</a>(int &amp;size_x,int &amp;size_y);

        int <a class="code" href="class_g3textureparameters.html#a17">SetCurrentMaxSize</a>(int size_x,int size_y);

        void <a class="code" href="class_g3textureparameters.html#a18">GetCurrentMaxSize</a>(int &amp;size_x,int &amp;size_y);

        int <a class="code" href="class_g3textureparameters.html#a19">SetMinSize</a>(int size_x,int size_y);

        void <a class="code" href="class_g3textureparameters.html#a20">GetMinSize</a>(int &amp;size_x,int &amp;size_y);


        // add to execute buffer
        void <a class="code" href="class_g3textureparameters.html#a21">put</a>(LPVOID &amp;lpPointer) const {
        <a class="code" href="d3dmacs.h.html#a8">OP_STATE_RENDER</a>(2, lpPointer);
        <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(D3DRENDERSTATE_WRAPU, wrap_s, lpPointer);
        <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(D3DRENDERSTATE_WRAPV, wrap_t, lpPointer);
        }

        // add to execute buffer
        void <a class="code" href="class_g3textureparameters.html#a22">putall</a>(LPVOID &amp;lpPointer) const {
        <a class="code" href="d3dmacs.h.html#a8">OP_STATE_RENDER</a>(3, lpPointer);
        //STATE_DATA(D3DRENDERSTATE_TEXTUREPERSPECTIVE, perspective, lpPointer);
                // WRAPU /WRAPV has a very different meansing, is set to false in SetState !!
        //STATE_DATA(D3DRENDERSTATE_WRAPU, wrap_s, lpPointer);
        //STATE_DATA(D3DRENDERSTATE_WRAPV, wrap_t, lpPointer);
        <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(D3DRENDERSTATE_TEXTUREMAG, mag_filter, lpPointer);
        <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(D3DRENDERSTATE_TEXTUREMIN, min_filter, lpPointer);
        <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(D3DRENDERSTATE_TEXTUREMAPBLEND, blend, lpPointer);
        }

};

const char * <a class="code" href="g3render.h.html#a61">GFogModeLookup</a>(int v);
int <a class="code" href="g3render.h.html#a61">GFogModeLookup</a>(const char *v);

//@class  Fog/Depth Cueing options (glFog)

#define G3FOG_VERTEX 1
#define G3FOG_TABLE 2
#define G3FOG_RANGE 4

class <a class="code" href="class_g3fog.html">G3Fog</a> {
public :
        gbool enable;  // glEnable

    D3DFOGMODE mode;    

        float start,end;
        float density;

        float index;

        gbool useBackgroundColor;

        <a class="code" href="class_rgbacolor.html">RGBAColor</a> color; // current color of fog 

        int fogHint;    // vertex, table, range 

    static const <a class="code" href="class_is.html">IS</a> modes[]; // table of filter names 


        void <a class="code" href="class_g3fog.html#a0">SetMode</a>(const char *Mode) {
        int v = Lookup(modes,Mode);
        if (v&gt;=0) mode  = (D3DFOGMODE) v;
        };
        const char * <a class="code" href="class_g3fog.html#a1">GetMode</a>() { return <a class="code" href="g3render.h.html#a61">GFogModeLookup</a>(mode); }



    <a class="code" href="class_g3fog.html#a2">G3Fog</a>() {
                        enable = 0;
                        mode = D3DFOG_EXP ;
                        density = 1.0;
                        start= 0.0;
                        end = 1.0;
                        index = 0.0;
                        useBackgroundColor = 0;
                        color.<a class="code" href="class_rgbacolor.html#a8">Gray</a>(0.0);        // Gl Default is Black();
                        fogHint = 0;
                        };

//      void SetQuality(int i) { if (i) fogHint = GL_NICEST; else fogHint = GL_FASTEST; }
//      int  GetQuality() { return (fogHint == GL_NICEST) ? 1 : 0; }

        
        // Evaluate float
        float <a class="code" href="class_ray.html#a2">Eval</a>(float z);
};



//@enum GRenderMode | predefined render modes
enum GRenderMode { 
                               GRenderVertices,         //@emem render only the vertices
                               GRenderBoundingBoxes,//@emem render bounding box of object only
                                   GRenderWireframe,    //@emem render only the edges
                               GRenderSolid,            //@emem render faces and edges with no lighting
                                   GRenderNonLighted,   //@emem render faces with no lighting
                                   GRenderFlat,                 //@emem render faces with flag lighting
                                   GRenderGouraud,              //@emem render faces with smooth lightings
                                   GRenderBBox,                 //@emem render only bounding box of object 
                                   GRenderCustom                //@emem mode is set to a custom mode
        };

const char * <a class="code" href="g3render.h.html#a63">GRenderModeLookup</a>(int v);
int <a class="code" href="g3render.h.html#a63">GRenderModeLookup</a>(const char *v);


//
// RenderState
// 


class <a class="code" href="class_renderstate.html">RenderState</a> : public <a class="code" href="class_grenderstate.html">GRenderState</a> 
{

public:

        
         HRESULT                                GLastError; // error variable 

     HWND                   hWnd;       /* handle of window being managed */

         // a frame counter to measure texture oldiness

         DWORD                                  currentFrame; // the current frame number
         
         LARGE_INTEGER                  currentFrameStartCounter; // QueryPerformanceCounter

         void <a class="code" href="class_renderstate.html#a0">IncrementFrame</a>()   { 
                                        currentFrame++;
                                        lastFramePrimsDrawn = primsDrawn;
                                        primsDrawn = 0;
                                        lastFrameTrisDrawn=trisDrawn;
                                        trisDrawn = 0;
                                        }

         inline DWORD <a class="code" href="class_renderstate.html#a1">GetCurrentFrame</a>() { return currentFrame; }
         
         void <a class="code" href="class_renderstate.html#a2">ResetFrame</a>()               {
                 lastFramePrimsDrawn = primsDrawn = 0;
                 lastFrameTrisDrawn=trisDrawn = 0;
                 currentFrame = 2; 
         }

         int primsDrawn;                        // number of geometric primitves
         int trisDrawn;                         // number of triangles drawn
         int lastFramePrimsDrawn;
         int lastFrameTrisDrawn;

         int currentTriBudget; // estimated target triangle budget for scene


         gbool <a class="code" href="class_renderstate.html#a3">IsOldFrame</a>(DWORD nr,DWORD delta) const { return (nr&lt;(currentFrame-delta)); }

         <a class="code" href="class_gd3device.html">GD3Device</a>                              *device;        /* point to GD3Device needed for device information */
     
     // DD Variables
     LPDIRECTDRAW           lpDD;       /* DirectDraw object */

     // D3D Variables

         LPDIRECT3D             lpD3D;      /* D3D object */
         LPDIRECT3DDEVICE       lpDev;      /* D3D device */
         LPDIRECT3DVIEWPORT     lpView;     /* D3D viewport */

         // DX 5 Support
         gbool dx5;
     
         LPDIRECT3D2              lpD3D2;         /* D3D 2 object */
     LPDIRECT3DDEVICE2        lpD3DDevice2;   /* D3D 2 device */
     LPDIRECT3DVIEWPORT2      lpD3DViewport2; /* D3D 2 viewport, created by application */

         // DX 6 Support
         gbool dx6;
     LPDIRECT3D3              lpD3D3;         /* D3D 3 object */
     LPDIRECT3DDEVICE3        lpD3DDevice3;   /* D3D 3 device */
     LPDIRECT3DVIEWPORT3      lpD3DViewport3; /* D3D 3 viewport, created by application */

         int                                      dxLevel;                // level of direct X supported

         gbool                                    dx6tex;                  // use DX6 Texture interfaces

         D3DDEVICEDESC                    caps;                   /* D3D caps */ 


         DWORD maxBufferSize;           // if &gt;0 max allowed size of execute buffer
         int maxVertexCount;            // if &gt;0 max allowed nr of points per execute buffer

         gbool canCull;                         // is culling supported (otherwise assume CCW culling done)
         gbool canDoRgbLighting;        // RGB Mode lighting ? 
         gbool canDoFog;                        // fog ??
         gbool canDoAlphaBlend;         // ALphablending of Materials &amp; Textues
         gbool canDoMipMap;                     // any mim-map formt ?
         gbool canDoAlphaStipple;
         gbool canDoAlphaTest;          // alpha testing working ?
         
         D3DTEXTUREFILTER maxMipfilter; // highest level of mip-map min filter supported

         // copy both faces to execute buffer ?
         inline gbool <a class="code" href="class_renderstate.html#a4">NeedBothFaces</a>() { return(!canCull &amp;&amp; !backfaceCulling); }

#ifdef G3RIGHT_HANDED
         gbool <a class="code" href="class_renderstate.html#a5">FlipFaces</a>() { return(!canCull &amp;&amp; !frontFaceCW); }
#else
         gbool <a class="code" href="class_renderstate.html#a5">FlipFaces</a>() { return(!canCull &amp;&amp; frontFaceCW); }
#endif

         // do we need to flip normals filling the exbuf ?
         inline gbool <a class="code" href="class_renderstate.html#a6">FlipNormals</a>() { return( /* !canCull &amp;&amp;  */frontFaceCW); }


         gbool <a class="code" href="class_renderstate.html#a7">QueryCaps</a>(D3DDEVICEDESC *pDesc=NULL);

         static inline 
         D3DCOLOR <a class="code" href="class_renderstate.html#d0">getD3DColor</a>(const <a class="code" href="class_rgbacolor.html">RGBAColor</a> &amp; color){ return D3DRGBA_X(color );} 



     // Helper functions 
         gbool <a class="code" href="class_g3exbuf.html#a9">Execute</a> (<a class="code" href="class_g3exbuf.html">G3ExBuf</a> &amp;exBuf) 
         { 
                 return exBuf.Execute(lpDev,lpView); 
         }
         
         gbool <a class="code" href="class_renderstate.html#a9">ExecuteDraw</a> (<a class="code" href="class_g3exbuf.html">G3ExBuf</a> &amp;exBuf) { 
                                <a class="code" href="class_renderstate.html#a13">FlushState</a>(); 
                                return exBuf.<a class="code" href="class_g3exbuf.html#a9">Execute</a>(lpDev,lpView); 
         }

         // a global buffer for putting state change instruction
         // buffer always open, flush with FlushState
         <a class="code" href="class_g3exbufdesc.html">G3ExBufDesc</a> stateBuf;

         // keep track on how many times BeginScene called 
         int beginSceneCnt;

         HRESULT <a class="code" href="class_renderstate.html#a10">BeginScene</a>() {
          ASSERT(beginSceneCnt == 0);
                  beginSceneCnt++;
                  HRESULT res=lpDev-&gt;BeginScene();
          if (res!=D3D_OK) 
                <a class="code" href="g3render.h.html#a1">D3DError</a>("BeginScene failed",res);
        return(res);
         }

         HRESULT <a class="code" href="class_renderstate.html#a11">EndScene</a>() {
            ASSERT(beginSceneCnt == 1);

                        HRESULT res=lpDev-&gt;EndScene();
            if (res!=D3D_OK) 
                <a class="code" href="g3render.h.html#a1">D3DError</a>("EndScene failed",res);

                beginSceneCnt--;
        return(res);
     }
    
         // apply any state changes // DX3
         void <a class="code" href="class_renderstate.html#a12">FlushState_</a>();
         
         inline void <a class="code" href="class_renderstate.html#a13">FlushState</a>() {
                 if (stateBuf.<a class="code" href="class_g3exbufptr.html#a1">Length</a>()&gt;0) <a class="code" href="class_renderstate.html#a12">FlushState_</a>();
         }

         inline void <a class="code" href="class_renderstate.html#a13">FlushState</a>(size_t space) {
                 if (space &gt;= (stateBuf.<a class="code" href="class_g3exbufptr.html#a3">Size</a>()-stateBuf.<a class="code" href="class_g3exbufptr.html#a1">Length</a>())) <a class="code" href="class_renderstate.html#a12">FlushState_</a>();
         }
         
         // init state buf 
         void <a class="code" href="class_renderstate.html#a15">InitState</a>(size_t size=1024) {
                 stateBuf.<a class="code" href="class_g3exbufdesc.html#a4">Create</a>(lpDev,size);
                 stateBuf.<a class="code" href="class_g3exbufdesc.html#a6">Lock</a>();
         }
        
         void <a class="code" href="class_renderstate.html#a16">TermState</a>() {
                 stateBuf.<a class="code" href="class_g3exbufdesc.html#a7">Unlock</a>();
                 stateBuf.<a class="code" href="class_g3exbufdesc.html#a10">Release</a>();
         }

         // set DX RenderState setting for DX3 .. DX5 
        inline void <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATETYPE dwRenderStateType,DWORD dwRenderState) {
                if (dx6) { 
#ifdef _DEBUG
                                GLastError = lpD3DDevice3-&gt;SetRenderState(dwRenderStateType,dwRenderState);
                        if (GLastError != D3D_OK)  <a class="code" href="g3render.h.html#a1">D3DError</a>("SetRenderState() failed",GLastError);

#else
                                lpD3DDevice3-&gt;SetRenderState(dwRenderStateType,dwRenderState);
#endif
                                return;
                }
                if (dx5) { 
#ifdef _DEBUG
                                GLastError = lpD3DDevice2-&gt;SetRenderState(dwRenderStateType,dwRenderState);
                        if (GLastError != D3D_OK)  <a class="code" href="g3render.h.html#a1">D3DError</a>("SetRenderState() failed",GLastError);

#else
                                lpD3DDevice2-&gt;SetRenderState(dwRenderStateType,dwRenderState);
#endif
                                return;
                }
        <a class="code" href="d3dmacs.h.html#a8">OP_STATE_RENDER</a>(1, stateBuf.lpPointer);
                        <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(dwRenderStateType, dwRenderState, stateBuf.lpPointer);
        }
        
        inline void <a class="code" href="class_renderstate.html#a18">SetRenderStateEB</a>(D3DRENDERSTATETYPE dwRenderStateType,DWORD dwRenderState) {
                if (doOwnLighting &amp;&amp; dx5) { 
#ifdef _DEBUG
                                GLastError = lpD3DDevice2-&gt;SetRenderState(dwRenderStateType,dwRenderState);
                        if (GLastError != D3D_OK)  <a class="code" href="g3render.h.html#a1">D3DError</a>("SetRenderState() failed",GLastError);

#else
                                lpD3DDevice2-&gt;SetRenderState(dwRenderStateType,dwRenderState);
#endif
                                return;
                }
        <a class="code" href="d3dmacs.h.html#a8">OP_STATE_RENDER</a>(1, stateBuf.lpPointer);
                        <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(dwRenderStateType, dwRenderState, stateBuf.lpPointer);
        }

        // problem with DX5 &amp; Exectue buffers, textures are not pers. correct 
        inline void <a class="code" href="class_renderstate.html#a19">SetRenderStateTex</a>(D3DRENDERSTATETYPE dwRenderStateType,DWORD dwRenderState) {
                if (dx6) { 
#ifdef _DEBUG
                                GLastError = lpD3DDevice3-&gt;SetRenderState(dwRenderStateType,dwRenderState);
                        if (GLastError != D3D_OK)  <a class="code" href="g3render.h.html#a1">D3DError</a>("SetRenderState() failed",GLastError);

#else
                                lpD3DDevice3-&gt;SetRenderState(dwRenderStateType,dwRenderState);
#endif
                                return;
                }
        <a class="code" href="d3dmacs.h.html#a8">OP_STATE_RENDER</a>(1, stateBuf.lpPointer);
                        <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(dwRenderStateType, dwRenderState, stateBuf.lpPointer);
        }

        void <a class="code" href="class_renderstate.html#a20">SetLightState</a>(D3DLIGHTSTATETYPE dwLightStateType,DWORD dwLightState) {
                if (dx5) { 
#ifdef _DEBUG
                                GLastError = lpD3DDevice2-&gt;SetLightState(dwLightStateType,dwLightState);
                        if (GLastError != D3D_OK)  <a class="code" href="g3render.h.html#a1">D3DError</a>("SetLightState() failed",GLastError);
#else
                                lpD3DDevice2-&gt;SetLightState(dwLightStateType,dwLightState);
#endif
                                return;
                }
        <a class="code" href="d3dmacs.h.html#a6">OP_STATE_LIGHT</a>(1, stateBuf.lpPointer);
                        <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(dwLightStateType, dwLightState, stateBuf.lpPointer);
        }

        void <a class="code" href="class_renderstate.html#a21">SetLightStateMat</a>(D3DLIGHTSTATETYPE dwLightStateType,DWORD dwLightState) {
                if (dx6) { 
#ifdef _DEBUG
                                GLastError = lpD3DDevice3-&gt;SetLightState(dwLightStateType,dwLightState);
                        if (GLastError != D3D_OK)  <a class="code" href="g3render.h.html#a1">D3DError</a>("SetLightState() failed",GLastError);
#else
                                lpD3DDevice3-&gt;SetLightState(dwLightStateType,dwLightState);
#endif
                                return;
                }
        <a class="code" href="d3dmacs.h.html#a6">OP_STATE_LIGHT</a>(1, stateBuf.lpPointer);
                        <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(dwLightStateType, dwLightState, stateBuf.lpPointer);
        }



     <a class="code" href="class_g3material.html">G3Material</a>    defaultMaterialValue; // value for defaul material 
     <a class="code" href="class_g3materialref.html">G3MaterialRef</a> defaultMaterial;


         <a class="code" href="class_g3materialref.html">G3MaterialRef</a> backgroundMaterial;
         <a class="code" href="class_gtextureref.html">GTextureRef</a>  backgroundTexture;


         DWORD materialRampSize;        // default 16

         gbool enableOwnLighting;       // global flag to enable custom &amp; transform lighting 
         gbool enableD3DCulling;        // global flag to enable custom &amp; transform lighting 
         gbool doOwnLighting;           // do our own lighting and transform
         gbool doD3DCulling;            // use D3D culling instead of our backface culling

         gbool lightsTransformed;   // lights already transformed to model space ?
         gbool lightsTransformedView; // lights already transformed to view space ?
         
         gbool materialChanged;         // material changed 
         gbool matrixChanged;           // model to world matrix changed

         gbool do2Dclip;                        // do we need clipping
         gbool devNeed2DClip;           // device needs clipping
         gbool useKatmai;                       // use Katmai code
         gbool useVertexBuffer;         // use D3D vertex buffer

         // global D3D D3DTLVERTEX buffer 
        
         // Array&lt;D3DTLVERTEX&gt; vtlBuffer;
         <a class="code" href="class_floatarrayaligned.html">FloatArrayAligned</a>  vtlBuffer;

         // global D3D index buffer 
         <a class="code" href="class_array.html">Array</a>&lt;WORD&gt; indexBuffer; // for DrawPrimitiveIndexed
                
         void *         katmaiState;    // Katmai Transform &amp; Light state data  

         <a class="code" href="class_g3materialhandle.html">G3MaterialHandle</a> *currentMaterial; // the current material 
         
         // to do: 
         // void ComputeLighting(Point &amp;p,Point &amp;n,D3DCCOLOR &amp;result);


         D3DTEXTUREHANDLE hTex;  /* Handle for the texture on the material.*/
     <a class="code" href="class_gtextureref.html">GTextureRef</a>  defaultTexture;


         <a class="code" href="class_matrix.html">Matrix</a> view;
         <a class="code" href="class_matrix.html">Matrix</a> projection;


         <a class="code" href="class_matrix.html">Matrix</a> model2screen; // new 


         // emulation of texture matrix
         <a class="code" href="class_matrix.html">Matrix</a> textureMatrix;
         



         // set texture matrix, version Id is incremented
         void <a class="code" href="class_grenderstate.html#a6">SetTextureMatrix</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;m) { textureMatrix = m; textureMatrixVersion++; textureMatrixIdentity = FALSE; }

         // set texture matrix, together with version ID, ID = 0, matrix is identity
         void <a class="code" href="class_grenderstate.html#a6">SetTextureMatrix</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;m, unsigned long version) { textureMatrix = m; textureMatrixVersion=version; textureMatrixIdentity = (version == 0); }

         void <a class="code" href="class_grenderstate.html#a8">SetTextureMatrixIdentity</a>() { if (!textureMatrixIdentity) { textureMatrix.<a class="code" href="class_matrix.html#a20">Identity</a>();  textureMatrixIdentity = TRUE; } }


         <a class="code" href="class_g3matrix.html">G3Matrix</a> viewMatrix;
         <a class="code" href="class_g3matrix.html">G3Matrix</a> projMatrix;
         <a class="code" href="class_g3matrix.html">G3Matrix</a> worldMatrix;

         void <a class="code" href="class_renderstate.html#a25">SetTransforms</a>(D3DMATRIXHANDLE hProj,
                                D3DMATRIXHANDLE hView,
                                D3DMATRIXHANDLE hWorld
        ) 
        {
     <a class="code" href="d3dmacs.h.html#a7">OP_STATE_TRANSFORM</a>(3, stateBuf.lpPointer);
        <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(D3DTRANSFORMSTATE_WORLD, hWorld, stateBuf.lpPointer);
        <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(D3DTRANSFORMSTATE_VIEW, hView, stateBuf.lpPointer);
        <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(D3DTRANSFORMSTATE_PROJECTION, hProj, stateBuf.lpPointer);
        }

    void <a class="code" href="class_renderstate.html#a26">SetWorldMatrix</a>(D3DMATRIX &amp;m)
    {
                if (doOwnLighting) {
                        lightsTransformed=gfalse;
                        matrixChanged=gtrue;
                        return;
                }

                worldMatrix.<a class="code" href="class_g3matrix.html#a4">Set</a>(lpDev,m);
                // if world matrix handle is current
                // no add to buffer is necessary 
        }

        void <a class="code" href="class_renderstate.html#a27">SetWorldMatrixIdentity</a>() {
                <a class="code" href="class_renderstate.html#a26">SetWorldMatrix</a>(G3Matrix::identity);
        }

        void <a class="code" href="class_renderstate.html#a26">SetWorldMatrix</a>(<a class="code" href="class_matrix.html">Matrix</a> &amp;m);

    
    int <a class="code" href="class_renderstate.html#a29">SetCamera</a>(<a class="code" href="class_gcamera.html">GCamera</a> *camera);


        void <a class="code" href="class_renderstate.html#a30">SetAmbientLight</a>() {
                <a class="code" href="class_renderstate.html#a20">SetLightState</a>(D3DLIGHTSTATE_AMBIENT, <a class="code" href="class_renderstate.html#d0">getD3DColor</a>(ambient));
        }

        //
        // set the rendering device context
        //


        void <a class="code" href="class_renderstate.html#a31">SetDevice</a>(<a class="code" href="class_gd3device.html">GD3Device</a> *newDevice);

        // one time initialization
        void <a class="code" href="class_renderstate.html#a32">Init</a>();
        void <a class="code" href="class_renderstate.html#a33">Term</a>();

    // at beginning of frame
    void <a class="code" href="class_renderstate.html#a34">SetState</a>();



    <a class="code" href="class_g3materialhandle.html">G3MaterialHandle</a>* materials; // list of all materials in use 
    <a class="code" href="class_g3texturehandle.html">G3TextureHandle</a>* textures; // list of all textures in use 
    
        <a class="code" href="class_g3lighthandle.html">G3LightHandle</a>* lights; // list of all lights in use 
        <a class="code" href="class_g3exbufhandle.html">G3ExBufHandle</a>* exBufs; // list of all execute buffers
        <a class="code" href="class_g3vbbufhandle.html">G3VBBufHandle</a>* VBBufs; // list of all vertex buffer

    // Set Material, if result FALSE, need definition of material 
    gbool <a class="code" href="class_renderstate.html#a184">SetMaterial</a>(<a class="code" href="class_g3materialref.html">G3MaterialRef</a> &amp;ref)
    {
                if (doOwnLighting) {
                        if (!ref.handle) return FALSE;
                        currentMaterial = ref.handle;
                        materialChanged=gtrue;
                        return TRUE;
                
                }
        if (!ref.Ok()) return(FALSE);
                if (!canDoRgbLighting &amp;&amp; (hTex != ref.handle-&gt;hTexture)) return (FALSE); // textures doesn´t match
        // ref.handle-&gt;put(stateBuf.lpPointer);
                <a class="code" href="class_renderstate.html#a21">SetLightStateMat</a>(D3DLIGHTSTATE_MATERIAL,ref.handle-&gt;hMat);
        return(TRUE);
    }
    
        gbool <a class="code" href="class_renderstate.html#a184">SetMaterial</a>(<a class="code" href="class_g3materialref.html">G3MaterialRef</a> &amp;ref,gbool whiteDiffuse)
    {
                if (doOwnLighting) {
                        if (!ref.handle) return FALSE;
                        
                        if (!ref.handle-&gt;defined) return (FALSE);
                        
                        if (whiteDiffuse != ref.handle-&gt;whiteDiffuse) return (FALSE); 
                        
                        currentMaterial = ref.handle;

                        materialChanged=gtrue;

                        return TRUE;
                
                }

        if (!ref.<a class="code" href="class_g3materialref.html#a1">Ok</a>()) return(FALSE);
                if (!canDoRgbLighting &amp;&amp; (hTex != ref.handle-&gt;hTexture)) return (FALSE); // textures doesn´t match
                if (whiteDiffuse != ref.handle-&gt;whiteDiffuse) return (FALSE); 
                <a class="code" href="class_renderstate.html#a21">SetLightStateMat</a>(D3DLIGHTSTATE_MATERIAL,ref.handle-&gt;hMat);
        return(TRUE);
    }

    // Set Material
    gbool <a class="code" href="class_renderstate.html#a184">SetMaterial</a>(<a class="code" href="class_g3materialref.html">G3MaterialRef</a> &amp;ref,                       
            // material parameters
                        float ambient[3],float diffuse[3],float specular[3],float emissive[3],
                        float alpha,float power,gbool whiteDiffuse);

    // Set Material solid 
    gbool <a class="code" href="class_renderstate.html#a184">SetMaterial</a>(<a class="code" href="class_g3materialref.html">G3MaterialRef</a> &amp;ref,const <a class="code" href="class_rgbacolor.html">RGBAColor</a> &amp;color);

        // set material properties
        gbool <a class="code" href="class_renderstate.html#a184">SetMaterial</a>(<a class="code" href="class_g3materialref.html">G3MaterialRef</a> &amp;ref,<a class="code" href="class_d3dmaterial.html">D3DMATERIAL</a> &amp;mat);
        
        // set material, but diffuse is white 
        gbool <a class="code" href="class_renderstate.html#a40">SetMaterialW</a>(<a class="code" href="class_g3materialref.html">G3MaterialRef</a> &amp;ref,<a class="code" href="class_d3dmaterial.html">D3DMATERIAL</a> &amp;mat); 
    
    // create a new material handle with a ref cnt of 1 
    <a class="code" href="class_g3materialhandle.html">G3MaterialHandle</a>* <a class="code" href="class_renderstate.html#a41">CreateMaterial</a>();

    // delete an no longer userd material
    void <a class="code" href="class_renderstate.html#a42">DeleteMaterial</a>(<a class="code" href="class_g3materialhandle.html">G3MaterialHandle</a> *m);

    // release all D3D Material handles
    void <a class="code" href="class_renderstate.html#a43">ReleaseMaterials</a>();

    // release all D3D Material handles using textures
    void <a class="code" href="class_renderstate.html#a44">ReleaseTexturedMaterials</a>();

    // Delete all D3D Material handles
    // should only be called if all references deleted !!!!!!!!!!!!1
    void <a class="code" href="class_renderstate.html#a45">DeleteMaterials</a>();

    // Delete all D3D Material handles
    // should only be called if all references deleted !!!!!!!!!!!!1
    void <a class="code" href="class_renderstate.html#a46">DeleteUnusedMaterials</a>();


    // Texture 
        gbool allTexturesInVideo; // all textures are fitting in video

        // D3DDevice texture formats of interest
        int palette8Format;
        int palette4Format;

        int rgbFormat;
        int rgb24Format;
        int rgb16Format;

        int rgbaFormat;
        int rgba32Format;
        int rgba16Format;
        int rgba16_1Format; // 1 bit alpha 

        int gray_format;                // Luminance
        int grayalpha_format;   // Lunminace alpha

        // find a texture format matching srcPixelFormat
        int <a class="code" href="class_renderstate.html#a47">FindTextureFormat</a>(DDPIXELFORMAT &amp;srcPixelFormat,DDPIXELFORMAT &amp;texFormat);


        int <a class="code" href="class_renderstate.html#a48">GetSupportedImageFormats</a>() { return textureParameters.supported_image_fmts; }


    gbool <a class="code" href="class_grenderstate.html#a1">SetTexture</a>(<a class="code" href="class_gtextureref.html">GTextureRef</a> &amp;ref)
    {
                if (dx6tex) 
                        return <a class="code" href="class_grenderstate.html#a1">SetTexture</a>((<a class="code" href="class_g3texturehandle2.html">G3TextureHandle2</a> *) ref.handle);

                <a class="code" href="class_g3texturehandle.html">G3TextureHandle</a> *h = (<a class="code" href="class_g3texturehandle.html">G3TextureHandle</a> *) ref.handle; // downcast  
        if (!ref.<a class="code" href="class_g3materialref.html#a1">Ok</a>()) return(FALSE);
                
                if (hTex == h-&gt;hTexture) {
                        //TRACE("Same texture handle %d \n",hTex);
                        return gtrue;
                }

        hTex = h-&gt;hTexture;
                h-&gt;rendered = TRUE;
                h-&gt;lastRenderedFrame = currentFrame;
                <a class="code" href="class_renderstate.html#a19">SetRenderStateTex</a>(D3DRENDERSTATE_TEXTUREHANDLE,hTex);
        return(TRUE);
    }

        // Direct X 3 Version
    gbool <a class="code" href="class_grenderstate.html#a1">SetTexture</a>(<a class="code" href="class_g3texturehandle.html">G3TextureHandle</a> *h)
    {
                if (h == NULL) return FALSE;
        if (!h-&gt;<a class="code" href="class_g3texturehandle.html#a12">Ok</a>()) return(FALSE);
                if (hTex == h-&gt;hTexture) {
                        //TRACE("Same texture handle %d \n",hTex);
                        return gtrue;
                }

        hTex = h-&gt;hTexture;
                h-&gt;rendered = TRUE;
                h-&gt;lastRenderedFrame = currentFrame;
                <a class="code" href="class_renderstate.html#a19">SetRenderStateTex</a>(D3DRENDERSTATE_TEXTUREHANDLE,hTex);
        return(TRUE);

        }

        // Direct X 6 Version
    gbool <a class="code" href="class_grenderstate.html#a1">SetTexture</a>(<a class="code" href="class_g3texturehandle2.html">G3TextureHandle2</a> *h)
    {
                if (h == NULL) return FALSE;
        if (!h-&gt;<a class="code" href="class_g3texturehandle.html#a12">Ok</a>()) return(FALSE);
/*              
                if (hTex == h-&gt;hTexture) {
                        //TRACE("Same texture handle %d \n",hTex);
                        return gtrue;
                }

        hTex = h-&gt;hTexture;
*/
                h-&gt;rendered = TRUE;
                h-&gt;lastRenderedFrame = currentFrame;

                <a class="code" href="g3render.h.html#a2">D3DCheck</a>(lpD3DDevice3-&gt;SetTexture( 0, h-&gt;lpTexture));

        return(TRUE);
    }


        // Reload Texture, if it has been flushed 
    gbool <a class="code" href="class_renderstate.html#a52">ReloadTexture</a>(<a class="code" href="class_gtextureref.html">GTextureRef</a> &amp;ref)
    {   gbool ret = FALSE;
                if (ref.handle == NULL) return (FALSE); // never defined
                
                <a class="code" href="class_g3texturehandle.html">G3TextureHandle</a> *h = (<a class="code" href="class_g3texturehandle.html">G3TextureHandle</a> *) ref.handle; // downcast  

        if (!ref.handle-&gt;<a class="code" href="class_g3exbuf.html#a3">Ok</a>()) {
                   if (ref.handle-&gt;<a class="code" href="class_gtexturehandle.html#a6">CantLoad</a>()) 
                           return (FALSE); // file lost !!!

                   ret = h-&gt;<a class="code" href="class_g3texturehandle.html#a6">LoadTextureSurf</a>(device,*this);
                }

        hTex = h-&gt;hTexture;
                h-&gt;rendered = TRUE;
                h-&gt;lastRenderedFrame = currentFrame;
                <a class="code" href="class_renderstate.html#a19">SetRenderStateTex</a>(D3DRENDERSTATE_TEXTUREHANDLE,hTex);
        return(ret);
    }


        // set Texture properties
        gbool <a class="code" href="class_grenderstate.html#a1">SetTexture</a>(<a class="code" href="class_gtextureref.html">GTextureRef</a> &amp;ref,
                                                                LPCTSTR fileName,
                                                                LPCTSTR fileUrl,
                                                                int format = 0,gbool reload=gfalse); 
        // set Texture properties
        // find if a texture with this URL already loaded 
        gbool <a class="code" href="class_grenderstate.html#a2">FindTextureByUrl</a>(<a class="code" href="class_gtextureref.html">GTextureRef</a> &amp;ref,LPCTSTR fileUrl); 

        // set by image data 
        gbool <a class="code" href="class_grenderstate.html#a1">SetTexture</a>(<a class="code" href="class_gtextureref.html">GTextureRef</a> &amp;ref,int glFormat,int width,int height,int numComponents,unsigned char *data);

        // set texture by image structure 
        gbool <a class="code" href="class_grenderstate.html#a1">SetTexture</a>(<a class="code" href="class_gtextureref.html">GTextureRef</a> &amp;ref,<a class="code" href="class_image_.html">image</a> *im,gbool checkScale=TRUE);

        // set texture by DD surface 
        gbool <a class="code" href="class_grenderstate.html#a1">SetTexture</a>(<a class="code" href="class_gtextureref.html">GTextureRef</a> &amp;ref,LPDIRECTDRAWSURFACE srcSurface,IDirectDrawPalette *srcPalette,DDSURFACEDESC &amp;srcDdsd, RECT &amp;srcRect,gbool checkScale=TRUE,RECT *targetSizeRect=NULL);


        gbool <a class="code" href="class_renderstate.html#a58">SetDefaultTexture</a>(const char *fileName,int format = 0) 
    {
        return(<a class="code" href="class_grenderstate.html#a1">SetTexture</a>(defaultTexture,fileName,NULL,format));
    }

    void <a class="code" href="class_renderstate.html#a59">ReleaseDefaultTexture</a>() 
    {
      defaultTexture.<a class="code" href="class_gtextureref.html#a6">Release</a>();
    }


        gbool <a class="code" href="class_renderstate.html#a60">SetBackgroundTexture</a>(const char *fileName,int format = 0) 
    {
        if (<a class="code" href="class_grenderstate.html#a1">SetTexture</a>(backgroundTexture,fileName,NULL,format)) {
                        <a class="code" href="class_renderstate.html#a186">SetBackgroundColor</a>();
                        <a class="code" href="class_renderstate.html#a213">SetTextureOff</a>();
                        return(TRUE);
                }
                else return (FALSE);

    }

    void <a class="code" href="class_renderstate.html#a61">ReleaseBackgroundTexture</a>() 
    {
                backgroundTexture.<a class="code" href="class_gtextureref.html#a6">Release</a>();
    }

    <a class="code" href="class_g3texturehandle.html">G3TextureHandle</a>* <a class="code" href="class_renderstate.html#a62">CreateTexture</a>();

    void <a class="code" href="class_renderstate.html#a63">DeleteTexture</a>(<a class="code" href="class_g3texturehandle.html">G3TextureHandle</a> *m);
    void <a class="code" href="class_renderstate.html#a63">DeleteTexture</a>(<a class="code" href="class_gtexturehandle.html">GTextureHandle</a> *m) { <a class="code" href="class_renderstate.html#a63">DeleteTexture</a>((<a class="code" href="class_g3texturehandle.html">G3TextureHandle</a> *)m); }


        void <a class="code" href="class_grenderstate.html#a12">GetTextureTargetSize</a>(int &amp;width,int &amp;height,int roundUpLimit=128);

        void <a class="code" href="class_renderstate.html#a66">GetTextureMaxSize</a>(int &amp;size_x,int &amp;size_y) { textureParameters.<a class="code" href="class_g3textureparameters.html#a16">GetMaxSize</a>(size_x,size_y); }

        void <a class="code" href="class_renderstate.html#a67">GetTextureCurrentMaxSize</a>(int &amp;size_x,int &amp;size_y) { textureParameters.<a class="code" href="class_g3textureparameters.html#a18">GetCurrentMaxSize</a>(size_x,size_y); }

        void <a class="code" href="class_renderstate.html#a68">SetTextureCurrentMaxSize</a>(int size_x,int size_y) { textureParameters.<a class="code" href="class_g3textureparameters.html#a17">SetCurrentMaxSize</a>(size_x,size_y); }

        void <a class="code" href="class_renderstate.html#a69">GetTextureMinSize</a>(int &amp;size_x,int &amp;size_y)  { textureParameters.<a class="code" href="class_g3textureparameters.html#a20">GetMinSize</a>(size_x,size_y); }


  

    void <a class="code" href="class_grenderstate.html#a13">ReleaseTextures</a>();

    gbool <a class="code" href="class_grenderstate.html#a14">ReleaseUnrenderedTextures</a>(int max=1);

    gbool <a class="code" href="class_grenderstate.html#a15">ReleaseLargeTextures</a>(int max=1);

        gbool <a class="code" href="class_grenderstate.html#a16">GetMaxUsedTextureSize</a>(int &amp;sizeX,int &amp;sizeY, int &amp;bytesPerPix);



    void <a class="code" href="class_grenderstate.html#a17">DeleteTextures</a>();

    gbool <a class="code" href="class_grenderstate.html#a18">DeleteUnusedTextures</a>();

        gbool <a class="code" href="class_grenderstate.html#a19">OnTextureMemoryOverflow</a>(<a class="code" href="class_gtexturehandle.html">GTextureHandle</a> &amp;overflowHandle);


        // lights

        // cache for custom lighting 
        int numLights;
        <a class="code" href="class_g3lighthandle.html">G3LightHandle</a> *firstLight;

        // create a new light handle with a ref cnt of 1 
        <a class="code" href="class_g3lighthandle.html">G3LightHandle</a>* <a class="code" href="class_renderstate.html#a77">CreateLight</a>();

        // delete a no longer used light
        void <a class="code" href="class_renderstate.html#a78">DeleteLight</a>(<a class="code" href="class_g3lighthandle.html">G3LightHandle</a> *m);

        // release all D3D Light handles and remove from view 
        void <a class="code" href="class_renderstate.html#a79">ReleaseLights</a>();

        // Delete all D3D Light handles
        // should only be called if all references deleted !!!!!!!!!!!!
        void <a class="code" href="class_renderstate.html#a80">DeleteLights</a>();

        // Delete all unused D3D Light handles
        void <a class="code" href="class_renderstate.html#a81">DeleteUnusedLights</a>();

         // Set Light, define data and add to viewport 
        gbool <a class="code" href="class_renderstate.html#a82">SetLight</a>(<a class="code" href="class_g3lightref.html">G3LightRef</a> &amp;ref); 

        // Remove Light from viewport , but keep structure intact 
        void <a class="code" href="class_renderstate.html#a83">RemoveLight</a>(<a class="code" href="class_g3lightref.html">G3LightRef</a> &amp;ref)
        {
                if (ref.handle != NULL) {
                        if (ref.handle-&gt;enabled) ref.handle-&gt;Delete(lpView);
                }
        }

        // delete a no longer used light, use also to disable light 
        void <a class="code" href="class_renderstate.html#a78">DeleteLight</a>(<a class="code" href="class_g3lightref.html">G3LightRef</a> &amp;ref){
                if (ref.handle != NULL) {
            <a class="code" href="class_renderstate.html#a78">DeleteLight</a>(ref.handle);
                        ref.handle = NULL;
                }
        }


        // get the light handle info structure for light reference 
        // fill in data and call SetLight(ref)
        <a class="code" href="class_g3lighthandle.html">G3LightHandle</a>* <a class="code" href="class_renderstate.html#a85">GetLight</a>(<a class="code" href="class_g3lightref.html">G3LightRef</a> &amp;ref) 
        {
                if (ref.handle == NULL)
            ref.handle = <a class="code" href="class_renderstate.html#a77">CreateLight</a>();
                return ref.handle;
        }
                


        gbool <a class="code" href="class_renderstate.html#a82">SetLight</a>(<a class="code" href="class_g3lighthandle.html">G3LightHandle</a> *light)
        {       
                return light-&gt;Set(lpD3D);
        }

        gbool <a class="code" href="class_renderstate.html#a87">AddLight</a>(<a class="code" href="class_g3lighthandle.html">G3LightHandle</a> *light)
        {       
                return light-&gt;Add(lpView);
        }

        void <a class="code" href="class_renderstate.html#a88">UpdateAmbientLight</a>(); // recompute ambient light from all lights

        // light stack
        <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_g3lighthandle.html">G3LightHandle</a> *&gt; lightStack;

        // add/Enable  light at stack index I 
        gbool <a class="code" href="class_renderstate.html#a89">EnableLight</a>(int index, <a class="code" href="class_g3lightref.html">G3LightRef</a> &amp;ref);
        
        // remove light at stack index I 
        gbool <a class="code" href="class_renderstate.html#a90">DisableLight</a>(int index);



        // exBufs
        gbool exBufAddMat; // add material settings to execute buffer 
        gbool exBufCombine; // combine execute buffers 

    // create a new ExBuf handle with a ref cnt of 1 
    <a class="code" href="class_g3exbufhandle.html">G3ExBufHandle</a>* <a class="code" href="class_renderstate.html#a91">CreateExBuf</a>();

    // delete an no longer userd ExBuf
    void <a class="code" href="class_renderstate.html#a92">DeleteExBuf</a>(<a class="code" href="class_g3exbufhandle.html">G3ExBufHandle</a> *m);

    // release all D3D ExBuf handles
    void <a class="code" href="class_renderstate.html#a93">ReleaseExBufs</a>();

    // release all D3D ExBuf handles using textures
    void <a class="code" href="class_renderstate.html#a94">ReleaseTexturedExBufs</a>();

    // Delete all D3D ExBuf handles
    // should only be called if all references deleted !!!!!!!!!!!!1
    void <a class="code" href="class_renderstate.html#a95">DeleteExBufs</a>();

    // Delete all D3D ExBuf handles
    // should only be called if all references deleted !!!!!!!!!!!!1
    void <a class="code" href="class_renderstate.html#a96">DeleteUnusedExBufs</a>();


    //-----------------//-----------------//-----------------
        //                                              vertex buffer
        //-----------------//-----------------//-----------------
        

        gbool <a class="code" href="class_renderstate.html#a97">CreateVBBuf</a>(<a class="code" href="class_g3vbbufref.html">G3VBBufRef</a> &amp;bufRef,DWORD dwFVF, int iNumVerts);

        gbool <a class="code" href="class_renderstate.html#a98">LockVB</a>(<a class="code" href="class_g3vbbufref.html">G3VBBufRef</a> &amp;bufRef, D3DVALUE* &amp;pVertices)
        {
                GLastError =  bufRef.handle-&gt;lpD3DVBBuf-&gt;Lock(DDLOCK_WAIT | DDLOCK_WRITEONLY, (void **) &amp;pVertices, NULL);
                if (FAILED(GLastError)) {
                        <a class="code" href="g3render.h.html#a1">D3DError</a>("LockVB() failed",GLastError);
                        return gfalse;
                }
                return gtrue;
        }

        gbool <a class="code" href="class_renderstate.html#a99">UnlockVB</a>(<a class="code" href="class_g3vbbufref.html">G3VBBufRef</a> &amp;bufRef,gbool optimize=gfalse)
        {
                GLastError =  bufRef.handle-&gt;lpD3DVBBuf-&gt;Unlock();
                if (FAILED(GLastError)) {
                        <a class="code" href="g3render.h.html#a1">D3DError</a>("UnlockVB() failed",GLastError);
                        return gfalse;
                }
                if (optimize) {
                        GLastError =  bufRef.handle-&gt;lpD3DVBBuf-&gt;Optimize(lpD3DDevice3, 0);
                        if (GLastError != D3D_OK) <a class="code" href="g3render.h.html#a1">D3DError</a>("UnlockVB() Optimize failed",GLastError);
                }
                return gtrue;
        }

    void <a class="code" href="class_renderstate.html#a100">ReleaseVBBufs</a>();


    void <a class="code" href="class_renderstate.html#a101">DeleteVBBufs</a>();

    void <a class="code" href="class_renderstate.html#a102">DeleteUnusedVBBufs</a>();

    void <a class="code" href="class_renderstate.html#a103">DeleteVBBuf</a>(<a class="code" href="class_g3vbbufhandle.html">G3VBBufHandle</a> *m);

         void <a class="code" href="class_renderstate.html#a104">SetTextureParameters</a>();
         

         // flags keeping track of current render state
         gbool zbuffer;          // zbuffer enabled ?
         gbool wbuffer;          // wbuffer used instead of zbuffer ?

         D3DCMPFUNC depthFunc;  // depth func 
         
         gbool zwrite;                  // zbuffer write enabled ?

         gbool dither;                  // dithering enabled ?
         gbool lastPixel;                       // TRUE do not render last pixel 

         gbool alphaStipple;            // alpha stipple pattern enabled ? 
         gbool noDitherIfTextured;  // dithering enabled in texture mode  ?
         gbool specular;                        // sepcular hightlights
         int sbuffer;
         gbool lighting;                        // lighting needed
         int lightmodel;                        // light model FLAT/GOURAUD
         int fillMode;                          // POINT LINE FILL 
         gbool localColors;                     // use local face/vertex colors of object
         gbool backfaceCulling;
         int cullFront;
         gbool frontFaceCW;                     // glFrontFace


         gbool texturing;         // using texturing 
         gbool textureDefined;  // texture has been set
     int textureEnvMode;    //
         gbool twosidedLighting;
         gbool localViewer;       // gl local viewer

         gbool lineSmooth;        // line smooth
         int colorMaterial;             // glColorMaterial
         int colorMaterialBack;
         gbool computePrimitiveList;    // compute tristrips for shells

         gbool blend;                           // blend enabled
         gbool blendFromMaterial;       // blend test enabled from material

         D3DBLEND blendSrcFunc,blendDestFunc;   // Alpha blend function

         gbool alphaTest;                       // alpha test enabled
         gbool alphaTestFromTexture;// alpha test enabled from texture

         gbool colorKeyEnable;          // DX5 
         gbool alphaBlend;                      // DX5 

         gbool needBlendForCKey;        // device needs alpha blending for Texture with color key, true for DX3


         D3DCMPFUNC alphaFunc;          // ALPHA Comparison Function
         float alphaRef;                
         DWORD alphaRefI;                       // DX integer 0..255

         float alpha;                           // alpha value from material

         int normalize;                         // need normalization of normals
         float lightScale;                      // global light scale factor 

     // Hints 
     int perspectiveCorrectionHint;
     int pointSmoothHint;
     int lineSmoothHint;
     int polygonSmoothHint;
     
     // int fogHint; part of glFog 

         gbool fogEnabled;                              // fog  enabled

         <a class="code" href="class_g3fog.html">G3Fog</a> fog;                     // fog settings
         <a class="code" href="class_g3textureparameters.html">G3TextureParameters</a> textureParameters;

         D3DCOLORMODEL colorModel;


#if 0

         glBackground backgroundOptions;        // background settings

         glTextureGeneration textureGeneration;

         glMatrix modelMatrix;
         glMatrix projectionMatrix;
         glMatrix textureMatrix;
#endif

         <a class="code" href="class_transform3.html">Transform3</a> textureTransform3;



         void <a class="code" href="class_renderstate.html#a106">SetTextureTransform</a>(const <a class="code" href="class_transform3.html">Transform3</a> &amp;t) 
            {
                                textureTransform3 = t;
                                if (textureTransform3.<a class="code" href="class_transform3.html#a3">IsIdentity</a>())
                                        <a class="code" href="class_grenderstate.html#a8">SetTextureMatrixIdentity</a>();
                                else 
                                        <a class="code" href="class_grenderstate.html#a6">SetTextureMatrix</a>(textureTransform3.<a class="code" href="class_transform3.html#a4">Eval</a>());
                        }

     void <a class="code" href="class_renderstate.html#a106">SetTextureTransform</a>() {
                        //glMatrixMode(GL_TEXTURE);
                                //glLoadIdentity();
                                //textureTransform3.glSet();
                        //glMatrixMode(GL_MODELVIEW);
                        }


         void <a class="code" href="class_renderstate.html#a107">UnSetTextureTransform</a>() {
                        textureTransform3.<a class="code" href="class_transform3.html#a2">Identity</a>();
                        <a class="code" href="class_grenderstate.html#a8">SetTextureMatrixIdentity</a>();

                        //glMatrixMode(GL_TEXTURE);
                                //glLoadIdentity();
                        //glMatrixMode(GL_MODELVIEW);
                        }




         // limits
         int maxMmatrixStack;
         int maxLights;
         int maxTmatrixStack;

         <a class="code" href="class_rgbacolor.html">RGBAColor</a> background;
         <a class="code" href="class_rgbacolor.html">RGBAColor</a> ambient;             // ambient light color

         <a class="code" href="class_g3material.html">G3Material</a> material;
         <a class="code" href="class_g3material.html">G3Material</a> backMaterial;


         <a class="code" href="class_renderflags.html">RenderFlags</a> vertices;
         <a class="code" href="class_renderflags.html">RenderFlags</a> normals;
         <a class="code" href="class_renderflags.html">RenderFlags</a> edges;
         <a class="code" href="class_renderflags.html">RenderFlags</a> faces;
         <a class="code" href="class_renderflags.html">RenderFlags</a> bboxes;

         <a class="code" href="class_rgbacolor.html">RGBAColor</a> currentColor; // current unlit color
         D3DCOLOR  currentColorD3D; // and shadowed in DWORD
         
         inline D3DCOLOR <a class="code" href="class_renderstate.html#a108">getCurrentColorD3D</a>() { return currentColorD3D;} 
         
         <a class="code" href="class_rgbacolor.html">RGBAColor</a> vertexColor;
         <a class="code" href="class_rgbacolor.html">RGBAColor</a> edgeColor;
         <a class="code" href="class_rgbacolor.html">RGBAColor</a> faceColor;
         <a class="code" href="class_rgbacolor.html">RGBAColor</a> normalColor;
         <a class="code" href="class_rgbacolor.html">RGBAColor</a> bboxColor;

         float pointSize;
         float lineWidth;
     gbool   lineStipple; // glenable();   
     int   lineFactor;
     WORD  linePattern; 


         gbool  unlit; // flag TRUE create unlit ex.buffers false lit:
         gbool  litMaterial; //flag TRUE if current material is lighted

         // create unlit execute buffers 
         gbool <a class="code" href="class_renderstate.html#a109">Unlit</a>() { return(!litMaterial || unlit); } 



         GRenderMode renderMode;


         gbool LightMode;  // lighted wireframe ...
/*
         // Drawing extensions ......
         GExtendedDrawStyle *vertexDrawStyle,
                                                *edgeDrawStyle,
                                                *normalDrawStyle,
                                                *bboxDrawStyle;
*/


         <a class="code" href="class_renderstate.html#a110">RenderState</a>();
         <a class="code" href="class_renderstate.html#a111">~RenderState</a>();

         // clear buffers
         void <a class="code" href="class_g3exbuf.html#a12">Clear</a>();
         
         // clear buffers
         void <a class="code" href="class_g3exbuf.html#a12">Clear</a>(gbool colorBuffer,gbool zBuffer,gbool stencilBuffer=gfalse,gbool accumBuffer=gfalse); 

         // set current viewport rectangle
         void <a class="code" href="class_renderstate.html#a115">SetViewport</a>(int x,int y,int width, int height);

         // set current viewport to max rectangle
         void <a class="code" href="class_renderstate.html#a115">SetViewport</a>();

         // get current viewport
         void <a class="code" href="class_renderstate.html#a116">GetViewport</a>(int &amp;x,int &amp;y,int &amp;width, int &amp;height);

         // set global render mode to mode (enum)
     int <a class="code" href="class_renderstate.html#a117">SetRenderMode</a>(GRenderMode newMode);

         int <a class="code" href="class_renderstate.html#a118">SetRenderFlags</a>(<a class="code" href="class_renderflags.html">RenderFlags</a> &amp;flags);

         // Set current color, also change material color
         void <a class="code" href="class_renderstate.html#a119">SetColor</a>(<a class="code" href="class_rgbacolor.html">RGBAColor</a> &amp;c);
         
         // Set Rendering Attributes to vertex
         int <a class="code" href="class_renderstate.html#a120">SetVertexAttributes</a>();

         // Set Rendering Attributes to edge
         int <a class="code" href="class_renderstate.html#a121">SetEdgeAttributes</a>();

         // Set Rendering Attributes for faces
         int <a class="code" href="class_renderstate.html#a122">SetFaceAttributes</a>(); 

         // Set Rendering Attributes for normals
         int <a class="code" href="class_renderstate.html#a123">SetNormalAttributes</a>(); 

         // Set Rendering Attributes for bounding boxes
         int <a class="code" href="class_renderstate.html#a124">SetBBoxAttributes</a>(); 

         // set texture flags for faces edges vertices
         int <a class="code" href="class_renderstate.html#a125">SetAnyTexturing</a>(int state)
         {      
                faces.textured = state;
                edges.textured = state;
                vertices.textured = state;

                // disable alpha test if enabled only for texture
                if (!state) {
                        if (alphaTestFromTexture) {
                                <a class="code" href="class_renderstate.html#a161">SetAlphaTestFromTexture</a>(FALSE);
                        }
                        <a class="code" href="class_renderstate.html#a207">SetTexturing</a>(0);
                }
                return(state);
         }

         int <a class="code" href="class_renderstate.html#a126">SetAnyLighting</a>(int state)
         {      
                faces.lighted = state;
                edges.lighted = state;
                vertices.lighted = state;
                return(state);
         }


         
         int <a class="code" href="class_renderstate.html#a127">SetFaceTexturing</a>(int state)
         {      
                faces.textured = state;
                if (state &amp;&amp; faces.visible)
                        edges.textured = 0;
                return(state);
         }

         int <a class="code" href="class_renderstate.html#a128">SetEdgeTexturing</a>(int state)
         {      
                edges.textured = state;
                if (state &amp;&amp; edges.visible)
                        vertices.textured = 0;
                return(state);
         }

         int <a class="code" href="class_renderstate.html#a129">SetEdgeLighting</a>(int state)
         {      
                edges.lighted = state;
                return(state);
         }


     // set all cached glstate parameters 
     void <a class="code" href="class_renderstate.html#a130">SetContextAll</a>();
         
         // Set Z-Buffer Mode  on/off
        void <a class="code" href="class_renderstate.html#a132">SetZBuffer</a>(gbool Zbuffer) {
                if (zbuffer == Zbuffer) return;
                zbuffer = Zbuffer;
        <a class="code" href="class_renderstate.html#a132">SetZBuffer</a>();
    }

    void <a class="code" href="class_renderstate.html#a132">SetZBuffer</a>() {
                //if (zbuffer) glEnable(GL_DEPTH_TEST);
                //else glDisable(GL_DEPTH_TEST);
        <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_ZENABLE, (zbuffer ? (wbuffer ? D3DZB_USEW: D3DZB_TRUE) : D3DZB_FALSE));
         //SetRenderState(D3DRENDERSTATE_ZVISIBLE, zbuffer);

        };
        
        D3DZBUFFERTYPE  GetZBufferType() { return (zbuffer ? (wbuffer ? D3DZB_USEW: D3DZB_TRUE) : D3DZB_FALSE); }

         // Set Z-Buffer Mode  on/off
        void <a class="code" href="class_renderstate.html#a135">SetZWrite</a>(gbool ZWrite) {
                if (zwrite == ZWrite) return;
                zwrite = ZWrite;
        <a class="code" href="class_renderstate.html#a135">SetZWrite</a>();
    }

    void <a class="code" href="class_renderstate.html#a135">SetZWrite</a>() {
        <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_ZWRITEENABLE, zwrite);
        };

    void <a class="code" href="class_renderstate.html#a136">SetDepthFunc</a>() {
                <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_ZFUNC, depthFunc); 
        };

    void <a class="code" href="class_renderstate.html#a136">SetDepthFunc</a>(int /*D3DCMPFUNC*/ DepthFunc) {
                depthFunc= (D3DCMPFUNC) DepthFunc;
                <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_ZFUNC, depthFunc); // 29.05.99
        };

        void <a class="code" href="class_renderstate.html#a139">SetDither</a>(gbool Dither) {
                if (dither == Dither) return;
                dither = Dither;
        <a class="code" href="class_renderstate.html#a139">SetDither</a>();
    }

    void <a class="code" href="class_renderstate.html#a139">SetDither</a>() {
        <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_DITHERENABLE, dither);
        };

        void <a class="code" href="class_renderstate.html#a141">SetSpecular</a>(gbool Specular) {
                if (specular == Specular) return;
                specular = Specular;
        <a class="code" href="class_renderstate.html#a141">SetSpecular</a>();
    }

    void <a class="code" href="class_renderstate.html#a141">SetSpecular</a>() {
        <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_SPECULARENABLE, specular);
        };

        void <a class="code" href="class_renderstate.html#a143">SetLastPixelMode</a>(gbool LastPixel) {
                if (lastPixel == LastPixel) return;
                lastPixel = LastPixel;
        <a class="code" href="class_renderstate.html#a143">SetLastPixelMode</a>();
    }

    void <a class="code" href="class_renderstate.html#a143">SetLastPixelMode</a>() {
                //if (dither) glEnable(GL_DEPTH_TEST);
                //else glDisable(GL_DEPTH_TEST);
        <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_LASTPIXEL, lastPixel);
        };



        // Set Alpha Stipple  on/off
        void <a class="code" href="class_renderstate.html#a144">SetAlphaStippleDither</a>(gbool AlphaStipple) {
                if (alphaStipple == AlphaStipple) return;
                alphaStipple = AlphaStipple;
        <a class="code" href="class_renderstate.html#a145">SetAlphaStipple</a>();
    }

    void <a class="code" href="class_renderstate.html#a145">SetAlphaStipple</a>() {
         <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_STIPPLEDALPHA, alphaStipple);
        };


        void <a class="code" href="class_renderstate.html#a147">SetBlend</a>(gbool Blend) {
                if (blend == Blend) return;
                blend = Blend;
        <a class="code" href="class_renderstate.html#a147">SetBlend</a>();
    }

    void <a class="code" href="class_renderstate.html#a147">SetBlend</a>() {
                //if (blend) glEnable(GL_BLEND);
                //else glDisable(GL_BLEND);
                <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_BLENDENABLE, blend);
        };


        void <a class="code" href="class_renderstate.html#a149">SetAlphaBlend</a>(gbool Blend) {
                if (alphaBlend == Blend) return;
                alphaBlend = Blend;
        <a class="code" href="class_renderstate.html#a149">SetAlphaBlend</a>();
    }

    void <a class="code" href="class_renderstate.html#a149">SetAlphaBlend</a>() {
                if (!dx5) return;
                <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_ALPHABLENDENABLE, alphaBlend);

        };

        void <a class="code" href="class_renderstate.html#a151">SetColorKeyEnable</a>(gbool Blend) {
                if (colorKeyEnable == Blend) return;
                colorKeyEnable = Blend;
        <a class="code" href="class_renderstate.html#a151">SetColorKeyEnable</a>();
    }

    void <a class="code" href="class_renderstate.html#a151">SetColorKeyEnable</a>() {
                if (!dx5) return;
                <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_COLORKEYENABLE, colorKeyEnable);

        };



        void <a class="code" href="class_renderstate.html#a152">SetBlendFromMaterial</a>(gbool Blend) {
                if (blend == Blend) return;
                blend = Blend;
                blendFromMaterial = blend;
        <a class="code" href="class_renderstate.html#a147">SetBlend</a>();
    }

        void <a class="code" href="class_renderstate.html#a153">SetUnlit</a>();

        void <a class="code" href="class_renderstate.html#a153">SetUnlit</a>(gbool Unlit) {
                if (Unlit == unlit) return;
                unlit = Unlit;
        <a class="code" href="class_renderstate.html#a153">SetUnlit</a>();
    }

        void <a class="code" href="class_renderstate.html#a155">SetLitMaterial</a>(gbool Lit) {
                if (Lit == litMaterial) return;
                litMaterial = Lit;
    }


    void <a class="code" href="class_renderstate.html#a156">SetBlendFunc</a>(int BlendSrcFunc,int BlendDestFunc) 
        {
                blendSrcFunc=(D3DBLEND)BlendSrcFunc,blendDestFunc=(D3DBLEND)BlendDestFunc; 
                //glBlendFunc(blendSrcFunc,blendDestFunc);
                if (dx5) {
              lpD3DDevice2-&gt;SetRenderState(D3DRENDERSTATE_SRCBLEND  , blendSrcFunc);
                  lpD3DDevice2-&gt;SetRenderState(D3DRENDERSTATE_DESTBLEND , blendDestFunc);
                  return ;
                }
        <a class="code" href="d3dmacs.h.html#a8">OP_STATE_RENDER</a>(2, stateBuf.lpPointer);
              <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(D3DRENDERSTATE_SRCBLEND  , blendSrcFunc, stateBuf.lpPointer);
                  <a class="code" href="d3dmacs.h.html#a9">STATE_DATA</a>(D3DRENDERSTATE_DESTBLEND , blendDestFunc, stateBuf.lpPointer);

        }


        void <a class="code" href="class_renderstate.html#a157">SetMaterialAlpha</a>(float Alpha) 
        {
                alpha=Alpha;

                if (alpha &lt; 1.0) {
                        <a class="code" href="class_renderstate.html#a152">SetBlendFromMaterial</a>(TRUE);
                }
                else <a class="code" href="class_renderstate.html#a152">SetBlendFromMaterial</a>(FALSE);
        }

        void <a class="code" href="class_renderstate.html#a158">SetMaterialAlphaOff</a>() 
        {
                alpha=1.0;
                <a class="code" href="class_renderstate.html#a152">SetBlendFromMaterial</a>(FALSE);
        }

        // enable alpha test, needed for transparent textures 
        void <a class="code" href="class_renderstate.html#a160">SetAlphaTest</a>(gbool AlphaTest) {
                if (alphaTest == AlphaTest) return;
                alphaTest = AlphaTest;
        <a class="code" href="class_renderstate.html#a160">SetAlphaTest</a>();
    }

    void <a class="code" href="class_renderstate.html#a160">SetAlphaTest</a>() {
                //if (alphaTest) glEnable(GL_ALPHA_TEST);
                //else glDisable(GL_ALPHA_TEST);
            <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_ALPHATESTENABLE , alphaTest);

        };


        void <a class="code" href="class_renderstate.html#a161">SetAlphaTestFromTexture</a>(gbool AlphaTest) {
                if (alphaTest == AlphaTest) return;
                alphaTest = AlphaTest;
                alphaTestFromTexture = alphaTest;
        <a class="code" href="class_renderstate.html#a160">SetAlphaTest</a>();
    }

    void <a class="code" href="class_renderstate.html#a163">SetAlphaFunc</a>(int AlphaFunc,float AlphaRef) 
        {
                if (alphaFunc !=(D3DCMPFUNC) AlphaFunc) {
                        alphaFunc=(D3DCMPFUNC) AlphaFunc;
                        <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_ALPHAFUNC, alphaFunc);
                }

                if (alphaRef != AlphaRef) {
                        alphaRef=AlphaRef;
                        // glAlphaFunc(alphaFunc,alphaRef);
                        alphaRefI = 255.0*alphaRef;
                        if (alphaRefI&lt;0)  alphaRefI = 0;
                        else if (alphaRefI&gt;255)  alphaRefI = 255;
                        <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_ALPHAREF, alphaRefI);
                }

        }
    void <a class="code" href="class_renderstate.html#a163">SetAlphaFunc</a>() 
        {
                <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_ALPHAFUNC, alphaFunc);
                <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_ALPHAREF, alphaRefI);

        }


        void <a class="code" href="class_renderstate.html#a165">SetPointSize</a>(float PointSize) {
                pointSize = PointSize;
                //glPointSize(pointSize);
        }
        void <a class="code" href="class_renderstate.html#a165">SetPointSize</a>() {
                //glPointSize(pointSize);
        }

    void <a class="code" href="class_renderstate.html#a167">SetLineWidth</a>(float width) {
                lineWidth = width;
                //glLineWidth(lineWidth);
        }
    void <a class="code" href="class_renderstate.html#a167">SetLineWidth</a>() {
                //glLineWidth(lineWidth);
        }

    void <a class="code" href="class_renderstate.html#a168">SetLineStipple</a>()
    {
        if (lineStipple) {
            //glLineStipple(lineFactor,linePattern);
            //glEnable(GL_LINE_STIPPLE);
        }
        else {
            //glDisable(GL_LINE_STIPPLE);
        }
    }

         // Set Auto normalize  on/off
         void <a class="code" href="class_renderstate.html#a170">SetNormalize</a>(int Normalize) {
                        if (normalize == Normalize) return;
                        normalize = Normalize;
                        //if (normalize) glEnable(GL_NORMALIZE);
                        //else glDisable(GL_NORMALIZE);
        };

         void <a class="code" href="class_renderstate.html#a170">SetNormalize</a>() {
                        //if (normalize) glEnable(GL_NORMALIZE);
                        //else glDisable(GL_NORMALIZE);
         };

         // Set Light Mode on/off
         void <a class="code" href="class_renderstate.html#a172">SetLighting</a>(gbool Lighting) 
         {
                        if (lighting == Lighting) return;
                        lighting = Lighting;
         };
         
     void <a class="code" href="class_renderstate.html#a172">SetLighting</a>() 
         {
                        //if (lighting) glEnable(GL_LIGHTING);
                        //else glDisable(GL_LIGHTING);
         };

         void <a class="code" href="class_renderstate.html#a174">SetLightModel</a>(int Lightmodel) {
                        if (lightmodel == Lightmodel) return;
                        lightmodel = Lightmodel;
            <a class="code" href="class_renderstate.html#a174">SetLightModel</a>();
         };
         
         void <a class="code" href="class_renderstate.html#a174">SetLightModel</a>() {
            <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_SHADEMODE, lightmodel);

         };

     void <a class="code" href="class_renderstate.html#a176">SetFillMode</a>(int mode) {
                        if (fillMode == mode) return;
                        fillMode = mode;
            <a class="code" href="class_renderstate.html#a176">SetFillMode</a>();
         };
         
         void <a class="code" href="class_renderstate.html#a176">SetFillMode</a>() {
                        //glShadeModel(lightmodel);
            <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_FILLMODE, fillMode);
         };

        
        // set / get lightScale factor
        
        void <a class="code" href="class_renderstate.html#a177">SetLightScale</a>(float factor) { lightScale = factor; }
        
        float <a class="code" href="class_renderstate.html#a178">GetLightScale</a>() { return(lightScale); }


         void <a class="code" href="class_renderstate.html#a180">SetTwoSidedLighting</a>(gbool Lighting) {
                        if (Lighting == twosidedLighting) return;
                        twosidedLighting = Lighting;
                        //glLightModeli(GL_LIGHT_MODEL_TWO_SIDE,twosidedLighting);
         };

     void <a class="code" href="class_renderstate.html#a180">SetTwoSidedLighting</a>() {
                        //glLightModeli(GL_LIGHT_MODEL_TWO_SIDE,twosidedLighting);
         };

         // mode = 0 specular reflection is computed fom the origin of eye coordinate sys.
         // otherwise simply in direction of - z
         void <a class="code" href="class_renderstate.html#a182">SetLocalViewer</a>(gbool mode) {
                        if (mode == localViewer) return;
                        localViewer = mode;
                        //glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,mode);
         };
         
     void <a class="code" href="class_renderstate.html#a182">SetLocalViewer</a>() {
                        //glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,localViewer);
         };

         gbool <a class="code" href="class_renderstate.html#a184">SetMaterial</a>(const <a class="code" href="class_g3material.html">G3Material</a> &amp;Material) {
                        //material = Material;
                        //material.glSet();
                        //if (localColors) material.diffuse.glSet();
            defaultMaterialValue = Material;
            return <a class="code" href="class_renderstate.html#a184">SetMaterial</a>();


         };
         gbool <a class="code" href="class_renderstate.html#a184">SetMaterial</a>() {
                        //material.glSet();
                        //if (localColors) material.diffuse.glSet();
                 defaultMaterialValue.hTexture = hTex; // new 17.09
         return <a class="code" href="class_renderstate.html#a184">SetMaterial</a>(defaultMaterial,defaultMaterialValue);
         };

         // set background color = gl clear color
         void <a class="code" href="class_renderstate.html#a186">SetBackgroundColor</a>(const <a class="code" href="class_rgbacolor.html">RGBAColor</a> &amp;Color) {
             background = Color;
         <a class="code" href="class_renderstate.html#a186">SetBackgroundColor</a>();
         };

     gbool <a class="code" href="class_renderstate.html#a186">SetBackgroundColor</a>() {  // seems to cause flash if called during each rendering cycle
            //hBackgroundMaterial.SetSolid (lpD3D,lpDev,background);
            //hBackgroundMaterial.SetBackground(lpView);
        if (backgroundMaterial.handle == NULL)
            backgroundMaterial.handle = <a class="code" href="class_renderstate.html#a41">CreateMaterial</a>();
           
           <a class="code" href="class_g3texturehandle.html">G3TextureHandle</a> *h = (<a class="code" href="class_g3texturehandle.html">G3TextureHandle</a> *) backgroundTexture.handle; // downcast  


       // set material properties
           if (backgroundMaterial.handle &amp;&amp; backgroundMaterial.handle-&gt;SetSolid(lpD3D,lpDev,background,(h ? h-&gt;<a class="code" href="class_g3texturehandle.html#a16">GetTextureHandle</a>():NULL))
                        ) {
                // set as background material
                backgroundMaterial.handle-&gt;SetBackground(lpView);
                return(TRUE);
       } else return(FALSE);
         };

         // set current color // e.g. material diffuse, needed for unlit execute buffers
         void <a class="code" href="class_renderstate.html#a187">SetCurrentColor</a>(const <a class="code" href="class_rgbacolor.html">RGBAColor</a> &amp;Color) {
             currentColor = Color;
                 currentColorD3D = <a class="code" href="class_renderstate.html#d0">getD3DColor</a>(currentColor);
         };

         void <a class="code" href="class_renderstate.html#a187">SetCurrentColor</a>(const <a class="code" href="class_point.html">Point</a> &amp;Color) {
             currentColor = Color;
                 currentColorD3D = <a class="code" href="class_renderstate.html#d0">getD3DColor</a>(currentColor);
         };

         void <a class="code" href="class_renderstate.html#a187">SetCurrentColor</a>(float r,float g,float b, float <a class="code" href="class_a.html">a</a>=1.0f) {
             currentColor.<a class="code" href="class_rgbacolor.html#a2">Set</a>(r,g,b,<a class="code" href="class_a.html">a</a>);
                 currentColorD3D = <a class="code" href="class_renderstate.html#d0">getD3DColor</a>(currentColor);
         };

         void <a class="code" href="class_renderstate.html#a190">SetFogEnable</a>(gbool flag) 
         {
                 if (fogEnabled == flag) return;
                 fogEnabled = flag;
                 <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_FOGENABLE, fogEnabled);
         }               

         
         void <a class="code" href="class_renderstate.html#a191">SetFog_</a>(); // lowlevel set 
        

         void <a class="code" href="class_renderstate.html#a192">SetFog</a>() {
                 if (fog.enable) {
                         <a class="code" href="class_renderstate.html#a191">SetFog_</a>();
                 }
                 else {
                        <a class="code" href="class_renderstate.html#a190">SetFogEnable</a>(FALSE);
                 }
         };

         void <a class="code" href="class_renderstate.html#a194">SetAmbientColor</a>(const <a class="code" href="class_rgbacolor.html">RGBAColor</a> &amp;Color) {
             ambient = Color;
                 ambient.a = Color.r;
                 <a class="code" href="class_renderstate.html#a194">SetAmbientColor</a>();
         };

         void <a class="code" href="class_renderstate.html#a194">SetAmbientColor</a>() {
                <a class="code" href="class_renderstate.html#a20">SetLightState</a>(D3DLIGHTSTATE_AMBIENT, <a class="code" href="class_renderstate.html#d0">getD3DColor</a>(ambient));
         };

         void <a class="code" href="class_renderstate.html#a195">SetColorModel</a>(D3DCOLORMODEL model)
         {
                colorModel = model;
                <a class="code" href="class_renderstate.html#a20">SetLightState</a>(D3DLIGHTSTATE_COLORMODEL, model);
         }

         void <a class="code" href="class_renderstate.html#a197">SetLocalColors</a>(gbool mode) {
                  if (mode == localColors) return;
                  localColors = mode;
          <a class="code" href="class_renderstate.html#a197">SetLocalColors</a>();
     }

     void <a class="code" href="class_renderstate.html#a197">SetLocalColors</a>() {
          if (localColors ) {
                  }
                  else;
         };

     // disable / enable backface culling 
         inline void <a class="code" href="class_renderstate.html#a199">SetBackfaceCulling</a>(gbool mode) {
                  if (mode == backfaceCulling) return;
                  backfaceCulling = mode;

          <a class="code" href="class_renderstate.html#a205">SetCulling</a>(backfaceCulling,frontFaceCW);
         };
         
     void <a class="code" href="class_renderstate.html#a199">SetBackfaceCulling</a>() {
         <a class="code" href="class_renderstate.html#a205">SetCulling</a>();
         };

         // mode 0 Front Facing polyongs are oriented counter clock wise
         // mode 1   "     "                                              clock wise
         inline void <a class="code" href="class_renderstate.html#a201">SetFrontFaceCW</a>(gbool mode) {
                  if (mode == frontFaceCW) return;
                  //glFrontFace(mode ? GL_CW : GL_CCW);
                  frontFaceCW = mode;
          <a class="code" href="class_renderstate.html#a203">SetCulling_</a>(backfaceCulling,frontFaceCW);
         };

         inline void <a class="code" href="class_renderstate.html#a201">SetFrontFaceCW</a>() {
                  //glFrontFace(frontFaceCW ? GL_CW : GL_CCW);
         <a class="code" href="class_renderstate.html#a205">SetCulling</a>();
         };

         // set both culling params in one call 
         inline void <a class="code" href="class_renderstate.html#a205">SetCulling</a>(gbool cull, gbool modeCW) {
                 backfaceCulling = cull;
                 frontFaceCW = modeCW;
         <a class="code" href="class_renderstate.html#a203">SetCulling_</a>(backfaceCulling,frontFaceCW);

         }

         // do render state settings if supported 
         inline void <a class="code" href="class_renderstate.html#a203">SetCulling_</a>(gbool cull, gbool modeCW) {
                        if (!canCull) return;

            D3DCULL c;
            if (cull) {
                if (modeCW) c= D3DCULL_CW;
                else c = D3DCULL_CCW;
            }    
            else c = D3DCULL_NONE;
            <a class="code" href="class_renderstate.html#a204">SetCullMode</a>(c);
     }

         D3DCULL currentCullMode;

         inline void <a class="code" href="class_renderstate.html#a204">SetCullMode</a>(D3DCULL cullMode) {
                if (cullMode != currentCullMode) {
                        currentCullMode = cullMode;
                        <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_CULLMODE,cullMode);
                }
        }

     
     void <a class="code" href="class_renderstate.html#a205">SetCulling</a>() {
        <a class="code" href="class_renderstate.html#a205">SetCulling</a>(backfaceCulling,frontFaceCW);
     }



     // disable/enable texturing 
         void <a class="code" href="class_renderstate.html#a207">SetTexturing</a>(gbool mode) {
                  if (mode == texturing) return;
                  if (mode ) {
                         //glEnable(GL_TEXTURE_2D);
                         //textureGeneration.glEnable_();
                  }
                  else {
                    //glDisable(GL_TEXTURE_2D);
                        //textureGeneration.glDisable_();
                        <a class="code" href="class_renderstate.html#a213">SetTextureOff</a>();
                  };
                  texturing = mode;
         };

         void <a class="code" href="class_renderstate.html#a207">SetTexturing</a>() {
                  if (texturing) {
                         //glEnable(GL_TEXTURE_2D);
                         //textureGeneration.glEnable_();
                  }
                  else {
                    //glDisable(GL_TEXTURE_2D);
                        //textureGeneration.glDisable_();
                        <a class="code" href="class_renderstate.html#a213">SetTextureOff</a>();
                  };
         };

         // if flag set_diffuse_white is set, set WHite on Texturing
         void <a class="code" href="class_renderstate.html#a208">SetTexturingDiffuseColor</a>(int setBorder=1) {
                if (texturing &amp;&amp; textureParameters.set_diffuse_white)
                {   //RGBAColor w;
                        //w.White();
                        //glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,&amp;w.r);
                        //w.glSet();
                        //if (setBorder) glTexParameterfv(GL_TEXTURE_2D,GL_TEXTURE_BORDER_COLOR,&amp;material.diffuse.r);
                }
        };

    // set texture wrapping 
        void <a class="code" href="class_renderstate.html#a209">SetTextureWrap</a>(gbool wrap_s, gbool wrap_t);

    // set texture filtering
        void <a class="code" href="class_renderstate.html#a210">SetTextureBlend</a>(D3DTEXTUREBLEND blend) 
        {
                if (blend != textureParameters.blend) {;
                        textureParameters.blend = blend;
                        <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_TEXTUREMAPBLEND, blend);
                }

        }

        void <a class="code" href="class_renderstate.html#a211">SetTextureBlend_</a>(D3DTEXTUREBLEND blend) {
                textureParameters.blend = blend;
            <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_TEXTUREMAPBLEND, blend);

        }



    // set texture handle
    void <a class="code" href="class_grenderstate.html#a1">SetTexture</a>(D3DTEXTUREHANDLE hTex) {
                this-&gt;hTex = hTex;
                <a class="code" href="class_renderstate.html#a19">SetRenderStateTex</a>(D3DRENDERSTATE_TEXTUREHANDLE,hTex);
        }

    void <a class="code" href="class_renderstate.html#a213">SetTextureOff</a>() {
                // if dx6Tex
                if (hTex != 0) {
                        hTex = 0;
                        <a class="code" href="class_renderstate.html#a19">SetRenderStateTex</a>(D3DRENDERSTATE_TEXTUREHANDLE,hTex);
                }
        }


         // miMap LodBias 
         float mipMapLodBias; // def 0 normally -1 ..1 

         void <a class="code" href="class_renderstate.html#a216">SetMipMapLodBias</a>(float offset) {
                 if (offset != mipMapLodBias) {          
                        mipMapLodBias = offset;
                        <a class="code" href="class_renderstate.html#a216">SetMipMapLodBias</a>();
                 }      
     }    
         
         float <a class="code" href="class_renderstate.html#a215">GetMipMapLodBias</a>() {
                 return mipMapLodBias;
         }
         
     void <a class="code" href="class_renderstate.html#a216">SetMipMapLodBias</a>() {
                <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_MIPMAPLODBIAS,mipMapLodBias);
         };

         int zBias; // 0 .. 16, default 0 

         void <a class="code" href="class_renderstate.html#a219">SetZBias</a>(int offset) {
                 if (offset != zBias) {          
                        zBias = offset;
                        <a class="code" href="class_renderstate.html#a219">SetZBias</a>();
                 }      
     }    
         
         int <a class="code" href="class_renderstate.html#a218">GetZBias</a>() {
                 return zBias;
         }
         
     void <a class="code" href="class_renderstate.html#a219">SetZBias</a>() {
                <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_ZBIAS ,zBias);
         };


         // antialiasing 
         
         D3DANTIALIASMODE antialisMode;

         void <a class="code" href="class_renderstate.html#a222">SetAntialiasing</a>(gbool mode) {
                 if (mode )
                    antialisMode =       D3DANTIALIAS_SORTINDEPENDENT;
                 else antialisMode =  D3DANTIALIAS_NONE;
         <a class="code" href="class_renderstate.html#a222">SetAntialiasing</a>();
     }    
         
         gbool <a class="code" href="class_renderstate.html#a221">GetAntialiasing</a>() {
                 return antialisMode &gt; D3DANTIALIAS_NONE;
         }
         
     void <a class="code" href="class_renderstate.html#a222">SetAntialiasing</a>() {
                <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_ANTIALIAS, antialisMode);
         };



         void <a class="code" href="class_renderstate.html#a224">SetLineAntialiasing</a>(gbool mode) {
         lineSmooth = mode;
         <a class="code" href="class_renderstate.html#a224">SetLineAntialiasing</a>();
     }    
         
     void <a class="code" href="class_renderstate.html#a224">SetLineAntialiasing</a>() {
                // SetRenderState(D3DRENDERSTATE_ANTIALIAS, lineSmooth);
         };
     
     void <a class="code" href="class_renderstate.html#a225">SetPerspectiveCorrectionHint</a>(int hint) {
         perspectiveCorrectionHint = hint;
         //glHint(GL_PERSPECTIVE_CORRECTION_HINT,perspectiveCorrectionHint);
         <a class="code" href="class_renderstate.html#a17">SetRenderState</a>(D3DRENDERSTATE_TEXTUREPERSPECTIVE, perspectiveCorrectionHint);
     }   

     void <a class="code" href="class_renderstate.html#a226">SetComputePrimitiveList</a>(gbool flag) { computePrimitiveList = flag; }


         // primitive Rendering 
         void <a class="code" href="class_renderstate.html#a227">RenderVertex</a>(<a class="code" href="class_point.html">Point</a> &amp;p);
         void <a class="code" href="class_renderstate.html#a228">RenderLine</a>(<a class="code" href="class_point.html">Point</a> &amp;p1,<a class="code" href="class_point.html">Point</a> &amp;p2);
         void <a class="code" href="class_renderstate.html#a229">RenderBBox</a>(<a class="code" href="class_point.html">Point</a> &amp;p1,<a class="code" href="class_point.html">Point</a> &amp;p2);
         void <a class="code" href="class_renderstate.html#a230">RenderCylinder</a>(<a class="code" href="class_point.html">Point</a> &amp;p, float r, float h);
         void <a class="code" href="class_renderstate.html#a231">RenderCone</a>(<a class="code" href="class_point.html">Point</a> &amp;p, float r, float h);
         //void RenderSphere(Point &amp;p,float r);

         // get GL limits of interes for our renderer
         void <a class="code" href="class_renderstate.html#a232">GetLimits</a>() {
                 //GLint i;
                 //glGetIntegerv(GL_MAX_MODELVIEW_STACK_DEPTH,&amp;i); maxMmatrixStack=i;
                 //glGetIntegerv(GL_MAX_TEXTURE_STACK_DEPTH,&amp;i); maxTmatrixStack=i;
                 //glGetIntegerv(GL_MAX_LIGHTS,&amp;i); maxLights=i;
                 maxLights = 128; // some number
          };

    


         // End of rendering to this frame
         void <a class="code" href="class_renderstate.html#a233">Finish</a>()
         {
                //glFinish();
         };

         // cache
         //glCache modelCache;
         //glCache textureCache;


         int (*AbortChecker)(<a class="code" href="class_renderstate.html">RenderState</a> &amp;s);
         void * AbortCheckerData;
         int doAbortCheck;

         float LastFrameTime; // Time needed to do last update
         
         // Check if redraw should be aborted
         int <a class="code" href="class_renderstate.html#a234">Abort</a>() {  if (doAbortCheck)  return(<a class="code" href="class_renderstate.html#a418">AbortChecker</a>(*this));
                                        return(0);
                            }
        // 
        int bufferMode; // 0 swapbuffers, 1 front buffer, 2 scale

        void <a class="code" href="class_renderstate.html#a235">SetBufferMode</a>(int mode);
        int <a class="code" href="class_renderstate.html#a236">GetBufferMode</a>() { return(bufferMode); }
        int <a class="code" href="class_renderstate.html#a237">SwapBuffers</a>();
        
        int <a class="code" href="class_renderstate.html#a238">UpdateFrontBuffer</a>();


        //@cmember viewport (window) size in pixel
        int sizex,sizey;
        
        //@cmember rendering viewport size in pixel
        int renderSizex,renderSizey;

        void <a class="code" href="class_g3exbufptr.html#a5">SetSize</a>(int sizeX,int sizeY);
        void <a class="code" href="class_renderstate.html#a240">SetRenderSize</a>(int sizex,int sizey);

        // Primitives
        void <a class="code" href="class_renderstate.html#a241">RenderSphere</a>(<a class="code" href="class_point.html">Point</a> &amp;center, float r=1.0,int level=1, int mask = 1, int VN=1, int FN=0);
        
        // render a wireframe cube 
        void <a class="code" href="class_renderstate.html#a242">RenderCubeEdges</a>(double x0, double y0,double z0,double x1,double y1,double z1);
        void <a class="code" href="class_renderstate.html#a242">RenderCubeEdges</a>(const <a class="code" href="class_point.html">Point</a> &amp;p0,const <a class="code" href="class_point.html">Point</a> &amp;p1);

        enum RenderElements {
                RVertices = 1,
                REdges = 2,
                RFaces = 4,
                RNormals = 8,
                RBBox   = 16
        };

        // caching help for qv
        // the material node, which recently has been set
        void * currentMaterialNode;
        void * currentBaseColorNode;
        int currentMaterialIndex;
        void *currentTexture2Node;
        void *currentCameraNode;
        int currentMaxLight;

        void <a class="code" href="class_renderstate.html#a244">FlushCurrent</a>() {
                currentMaterialNode = 0;
                currentBaseColorNode = 0;
                currentMaterialIndex = 0;
                currentTexture2Node = 0;
                currentCameraNode = 0;
                currentMaxLight=0;
        }

    
    // get functions pointers for extensions
    int <a class="code" href="class_renderstate.html#a245">InitializeExtensions</a>() { return(0); }

        <a class="code" href="class_grenderer2d.html">GRenderer2D</a>* <a class="code" href="class_grenderstate.html#a20">getRenderer2D</a>()  { return NULL; }

    // ******** end from glRender.h

};

/* from HELP file 

D3DOPCODE 

typedef enum _D3DOPCODE {
    D3DOP_POINT           = 1,
    D3DOP_LINE            = 2,
    D3DOP_TRIANGLE        = 3,
    D3DOP_MATRIXLOAD      = 4,
    D3DOP_MATRIXMULTIPLY  = 5,
    D3DOP_STATETRANSFORM  = 6,
    D3DOP_STATELIGHT      = 7,
    D3DOP_STATERENDER     = 8,
    D3DOP_PROCESSVERTICES = 9,
    D3DOP_TEXTURELOAD     = 10,
    D3DOP_EXIT            = 11,
    D3DOP_BRANCHFORWARD   = 12,
    D3DOP_SPAN            = 13,
    D3DOP_SETSTATUS       = 14,

} D3DOPCODE;


Contains the opcodes for execute buffers. 

D3DOP_POINT 

Sends a point to the renderer. Operand data is described by the D3DPOINT structure. 

D3DOP_LINE 

Sends a line to the renderer. Operand data is described by the D3DLINE structure. 

D3DOP_TRIANGLE 

Sends a triangle to the renderer. Operand data is described by the D3DTRIANGLE structure. 

D3DOP_MATRIXLOAD 

Triggers a data transfer in the rendering engine. Operand data is described by the D3DMATRIXLOAD structure. 

D3DOP_MATRIXMULTIPLY 

Triggers a data transfer in the rendering engine. Operand data is described by the D3DMATRIXMULTIPLY structure. 

D3DOP_STATETRANSFORM 

Sets the value of internal state variables in the rendering engine for the transformation module. Operand data is a variable token and the new value. The token identifies the internal state variable, and the new value is the value to which that variable should be set. For more information about these variables, see the D3DSTATE structure and the D3DTRANSFORMSTATETYPE enumerated type. 

D3DOP_STATELIGHT 

Sets the value of internal state variables in the rendering engine for the lighting module. Operand data is a variable token and the new value. The token identifies the internal state variable, and the new value is the value to which that variable should be set. For more information about these variables, see the D3DSTATE structure and the D3DLIGHTSTATETYPE enumerated type. 

D3DOP_STATERENDER 

Sets the value of internal state variables in the rendering engine for the rendering module. Operand data is a variable token and the new value. The token identifies the internal state variable, and the new value is the value to which that variable should be set. For more information about these variables, see the D3DSTATE structure and the D3DRENDERSTATETYPE enumerated type. 

D3DOP_PROCESSVERTICES 

Sets both lighting and transformations for vertices. Operand data is described by the D3DPROCESSVERTICES structure. 

D3DOP_TEXTURELOAD 

Triggers a data transfer in the rendering engine. Operand data is described by the D3DTEXTURELOAD structure. 

D3DOP_EXIT 

Signals that the end of the list has been reached. 

D3DOP_BRANCHFORWARD 

Enables a branching mechanism within the execute buffer. For more information, see the D3DBRANCH structure. 

D3DOP_SPAN 

Spans a list of points with the same y value. For more information, see the D3DSPAN structure. 

D3DOP_SETSTATUS 

Resets the status of the execute buffer. For more information, see the D3DSTATUS structure. 

An execute buffer has two parts: an array of vertices (each typically with position, normal vector, and texture coordinates) and an array of opcode/operand groups. One opcode can have several operands following it; the system simply performs the relevant operation on each operand. 



D3DRENDERSTATETYPE 
==================
typedef enum _D3DRENDERSTATETYPE {
    D3DRENDERSTATE_TEXTUREHANDLE      = 1,    
    D3DRENDERSTATE_ANTIALIAS          = 2,    
    D3DRENDERSTATE_TEXTUREADDRESS     = 3,    
    D3DRENDERSTATE_TEXTUREPERSPECTIVE = 4,    
    D3DRENDERSTATE_WRAPU              = 5,    
    D3DRENDERSTATE_WRAPV              = 6,    
    D3DRENDERSTATE_ZENABLE            = 7,    
    D3DRENDERSTATE_FILLMODE           = 8,    
    D3DRENDERSTATE_SHADEMODE          = 9,    
    D3DRENDERSTATE_LINEPATTERN        = 10,   

    D3DRENDERSTATE_MONOENABLE         = 11,   
    D3DRENDERSTATE_ROP2               = 12,   
    D3DRENDERSTATE_PLANEMASK          = 13,   
    D3DRENDERSTATE_ZWRITEENABLE       = 14,   
    D3DRENDERSTATE_ALPHATESTENABLE    = 15,   
    D3DRENDERSTATE_LASTPIXEL          = 16,   
    D3DRENDERSTATE_TEXTUREMAG         = 17,   
    D3DRENDERSTATE_TEXTUREMIN         = 18,   
    D3DRENDERSTATE_SRCBLEND           = 19,   
    D3DRENDERSTATE_DESTBLEND          = 20,   

    D3DRENDERSTATE_TEXTUREMAPBLEND    = 21,   
    D3DRENDERSTATE_CULLMODE           = 22,   
    D3DRENDERSTATE_ZFUNC              = 23,   
    D3DRENDERSTATE_ALPHAREF           = 24,   
    D3DRENDERSTATE_ALPHAFUNC          = 25,   
    D3DRENDERSTATE_DITHERENABLE       = 26,   
    D3DRENDERSTATE_BLENDENABLE        = 27,   
    D3DRENDERSTATE_FOGENABLE          = 28,   
    D3DRENDERSTATE_SPECULARENABLE     = 29,   
    D3DRENDERSTATE_ZVISIBLE           = 30,   

    D3DRENDERSTATE_SUBPIXEL           = 31,   
    D3DRENDERSTATE_SUBPIXELX          = 32,   
    D3DRENDERSTATE_STIPPLEDALPHA      = 33,   
    D3DRENDERSTATE_FOGCOLOR           = 34,   
    D3DRENDERSTATE_FOGTABLEMODE       = 35,   
    D3DRENDERSTATE_FOGTABLESTART      = 36,   
    D3DRENDERSTATE_FOGTABLEEND        = 37,   
    D3DRENDERSTATE_FOGTABLEDENSITY    = 38,   
    D3DRENDERSTATE_STIPPLEENABLE      = 39, 
    D3DRENDERSTATE_STIPPLEPATTERN00   = 64,
       // Stipple patterns 01 through 30 omitted here.

    D3DRENDERSTATE_STIPPLEPATTERN31   = 95,
} D3DRENDERSTATETYPE;


Describes the render state for the D3DOP_STATERENDER opcode. This enumerated type is part of the D3DSTATE structure. The values mentioned in the following descriptions are set in the second member of this structure. 

D3DRENDERSTATE_TEXTUREHANDLE 

Texture handle. The default value is NULL. 

D3DRENDERSTATE_ANTIALIAS 

Antialiasing primitive edges. The default value is FALSE. 

D3DRENDERSTATE_TEXTUREADDRESS 

One of the members of the D3DTEXTUREADDRESS enumerated type. The default value is D3DTADDRESS_WRAP. 

D3DRENDERSTATE_TEXTUREPERSPECTIVE 

TRUE for perspective correction. The default value is FALSE. 

D3DRENDERSTATE_WRAPU 

TRUE for wrapping in u direction. The default value is FALSE. 

D3DRENDERSTATE_WRAPV 

TRUE for wrapping in v direction. The default value is FALSE. 

D3DRENDERSTATE_ZENABLE 

TRUE to enable the z-buffer comparison test when writing to the frame buffer. The default value is FALSE. 

D3DRENDERSTATE_FILLMODE 

One or more members of the D3DFILLMODE enumerated type. The default value is D3DFILL_SOLID. 

D3DRENDERSTATE_SHADEMODE 

One or more members of the D3DSHADEMODE enumerated type. The default value is D3DSHADE_GOURAUD. 

D3DRENDERSTATE_LINEPATTERN 

The D3DLINEPATTERN structure. The default values are 0 for wRepeatPattern and 0 for wLinePattern. 

D3DRENDERSTATE_ROP2 

One of the 16 ROP2 binary raster operations specifying how the supplied pixels are combined with the pixels of the display surface. The default value is R2_COPYPEN. Applications can use the D3DPRASTERCAPS_ROP2 flag in the dwRasterCaps member of the D3DPRIMCAPS structure to determine whether additional raster operations are supported. 

D3DRENDERSTATE_PLANEMASK 

Physical plane mask whose type is ULONG. The default value is ~0. 

D3DRENDERSTATE_ZWRITEENABLE 

TRUE to enable z writes. The default value is TRUE. This member enables an application to prevent the system from updating the z-buffer with new z values. 

D3DRENDERSTATE_ALPHATESTENABLE 

TRUE to enable alpha tests. The default value is FALSE. This member enables applications to turn off the tests that otherwise would accept or reject a pixel based on its alpha value. 

D3DRENDERSTATE_LASTPIXEL 

TRUE to prevent drawing the last pixel in a line. The default value is FALSE. 

D3DRENDERSTATE_TEXTUREMAG 

One of the members of the D3DTEXTUREFILTER enumerated type. The default value is D3DFILTER_NEAREST. 

D3DRENDERSTATE_TEXTUREMIN 

One of the members of the D3DTEXTUREFILTER enumerated type. The default value is D3DFILTER_NEAREST. 

D3DRENDERSTATE_SRCBLEND 

One of the members of the D3DBLEND enumerated type. The default value is D3DBLEND_ONE. 

D3DRENDERSTATE_DSTBLEND 

One of the members of the D3DBLEND enumerated type. The default value is D3DBLEND_ZERO. 

D3DRENDERSTATE_TEXTUREMAPBLEND 

One of the members of the D3DTEXTUREBLEND enumerated type. The default value is D3DTBLEND_MODULATE. 

D3DRENDERSTATE_CULLMODE 

One of the members of the D3DCULL enumerated type. The default value is D3DCULL_CCW. Software renderers have a fixed culling order and do not support changing the culling mode. 

D3DRENDERSTATE_ZFUNC 

One of the members of the D3DCMPFUNC enumerated type. The default value is D3DCMP_LESSEQUAL. This member enables an application to accept or reject a pixel based on its distance from the camera. 

D3DRENDERSTATE_ALPHAREF 

Value specifying a reference alpha value against which pixels are tested when alpha-testing is enabled. This value's type is D3DFIXED. The default value is 0. 

D3DRENDERSTATE_ALPHAFUNC 

One of the members of the D3DCMPFUNC enumerated type. The default value is D3DCMP_ALWAYS. This member enables an application to accept or reject a pixel based on its alpha value. 

D3DRENDERSTATE_DITHERENABLE 

TRUE to enable dithering. The default value is FALSE. 

D3DRENDERSTATE_BLENDENABLE 

TRUE to enable alpha blending. The default value is FALSE. 

D3DRENDERSTATE_FOGENABLE 

TRUE to enable fog. The default value is FALSE. 

D3DRENDERSTATE_SPECULARENABLE 

TRUE to enable specular. The default value is TRUE. 

D3DRENDERSTATE_ZVISIBLE 

TRUE to enable z-checking. The default value is FALSE. Z-checking is a culling technique in which a polygon representing the screen space of an entire group of polygons is tested against the z-buffer to discover whether any of the polygons should be drawn. 

D3DRENDERSTATE_SUBPIXEL 

TRUE to enable subpixel correction. The default value is FALSE. 

D3DRENDERSTATE_SUBPIXELX 

TRUE to enable correction in X only. The default value is FALSE. 

D3DRENDERSTATE_STIPPLEDALPHA 

TRUE to enable stippled alpha. The default value is FALSE. 

D3DRENDERSTATE_FOGCOLOR 

Value whose type is D3DCOLOR. The default value is 0. 

D3DRENDERSTATE_FOGTABLEMODE 

One of the members of the D3DFOGMODE enumerated type. The default value is D3DFOG_NONE. 

D3DRENDERSTATE_FOGTABLESTART 

Fog table start. This is the position at which fog effects begin for linear fog mode. 

D3DRENDERSTATE_FOGTABLEEND 

Fog table end. This is the position at which fog effects reach their maximum density for linear fog mode. 

D3DRENDERSTATE_FOGTABLEDENSITY 

Sets the maximum fog density for linear fog mode. This value can range from 0 to 1. 

D3DRENDERSTATE_STIPPLEENABLE 

Enables stippling in the device driver. When stippled alpha is enabled, it must override the current stipple pattern. When stippled alpha is disabled, the stipple pattern must be returned. 

D3DRENDERSTATE_STIPPLEPATTERN00 through D3DRENDERSTATE_STIPPLEPATTERN31 

Stipple pattern. Each render state applies to a separate line of the stipple pattern. 


*/

#endif
</div></pre><hr><address><small>Generated at Thu Jan 27 18:51:25 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>
